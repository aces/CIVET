#! /usr/bin/env perl

############################################################################
############################################################################
### Run CIVET-VBM processing pipeline within the PMP framework. 
###         
###   In the current version, CIVET-VBM requires a quarantine of the software
###   invoked and an environment file.
###                                       
###   Authors:                                  
###         Original pipeline scripts by: Jason Lerch 
###         Pre-modular versions of CIVET: Yasser Ad-Dab'bagh             
###         Modular CIVET: Oliver Lyttelton, J-Sebastian Muehlboeck, 
###                        Yasser Ad-Dab'bagh, Kelvin Mok, Claude Lepage
###         Project started in May 3, 2005       
###       
### For more information, have a look at our documentation at:
###    http://wiki.bic.mni.mcgill.ca/index.php/CIVET
###                                 
############################################################################
############################################################################

use strict;
use FindBin;
use Cwd qw( abs_path );
use Env qw( PATH );

# All modules that will be used in either case are declared here
use Getopt::Tabular;
use PMP::PMP;
use PMP::pbs;
use PMP::sge;
use PMP::spawn;
use PMP::Array;
use MNI::Startup;
use MNI::PathUtilities qw(split_path);
use MNI::FileUtilities qw(check_output_dirs check_output_path);
use MNI::DataDir;

use lib "$FindBin::Bin";
use MRI_Image;
use VBM_Main;

$PATH = "$FindBin::Bin/progs:${PATH}";

# Set interrupt handler (for cleaning of lock files)
$SIG{'INT'} = 'CLEANUP';
$SIG{'TERM'} = 'CLEANUP';

my $version = "1.0";
my $versionDate= "Sept 27, 2007";
my $authors= "Yasser Ad-Dab\'bagh, Oliver Lyttelton, J-Sebastian Muehlboeck, Kelvin Mok, and Claude Lepage";
my $usage = "\nUSAGE:\n$ProgramName -sourcedir <dir> -targetdir <dir> -prefix <prefix> [options] id1 id2 ... idn > <logfile> &\n 
ALTERNATIVE USAGE:\n
$ProgramName -sourcedir <dir> -targetdir <dir> -prefix <prefix> -id-file <idfile> [options]  > <logfile> &\n\n";

my $whatsnew = <<NEW;
    *************************************************************************

    New in $versionDate quarantine, version $version

    1 - Initial implementation of VBM in CIVET. This is a separate pipeline for now
        that you can run on top of old CIVET runs, from CIVET-1.1.3 to today.

    More to come soon:

    1 - Full integration into CIVET.

    *************************************************************************
NEW

my $help = <<HELP;

$ProgramName, version $version, released $versionDate.
    Released by $authors.

    Complementary pipeline for CIVET to process the classified image for
    the purposes of VBM analyses. This pipeline is separate from CIVET at
    this time to allow running VBM on old CIVET runs. VBM possibilities 
    will be integrated in the next CIVET version.

$whatsnew
HELP
Getopt::Tabular::SetHelp($help, $usage);

####################
# Argument handling:
####################

my $reset = undef;
my $command = "printStatus";

# Queuing defaults:
my $PMPtype = "sge";
my $PMPgranularity = 0;
my $PMPmaxQueued = 10000;
my %PMPconf = ( 'spawn' => { 'queue' => undef,
                             'hosts' => undef,
                             'opts' => undef },
                'sge'   => { 'queue' => "all.q",
                             'hosts' => undef,
                             'opts' => undef },
                'pbs'   => { 'queue' => "brain",
                             'hosts' => undef,
                             'opts' => "-l ncpus=1" } );

my $resetRunning = 1;

############# Default models for pipeline

my $CIVETModel = "icbm152nl";
my $TemplateSize = "1.00";

### add avg64 model for cortical_surface, sphere models, 

my %CIVETmodels = ( 'icbm152nl' => {
                      'RegLinDir'        => MNI::DataDir::dir("mni_autoreg"),
                      'RegLinModel'      => "icbm_avg_152_t1_tal_nlin_symmetric_VI",
                      'RegNLDir'         => MNI::DataDir::dir("mni_autoreg"),
                      'RegNLModel'       => "icbm_avg_152_t1_tal_nlin_symmetric_VI",
                      'TemplateDir'      => MNI::DataDir::dir("ICBM"),
                      'TemplateModel'    => "icbm_template",
                      'SurfaceMaskDir'   => MNI::DataDir::dir("mni_autoreg"),
                      'SurfaceMask'      => "icbm_avg_152_t1_tal_nlin_symmetric_VI_mask.obj",
                      'SurfRegModelDir'  => "$FindBin::Bin/models",
                      'SurfRegModel'     => "surf_reg_model_left.obj",
                      'SurfRegDataTerm'  => "surf_reg_model_left.txt",
                      'TagFileDir'       => MNI::DataDir::dir("classify"),
                      'TagFile'          => "n/a",
                      'AnimalAtlas'      => "-symmetric_atlas",
                      'AnimalNLRegDir'   => MNI::DataDir::dir("mni_autoreg"),
                      'AnimalNLRegModel' => "icbm_avg_152_t1_tal_lin_symmetric"
                      # not yet ready and it you try to use this it will break. CL.
                      # 'AnimalAtlas'      => "-lobe_atlas",
                      # 'AnimalNLRegDir'   => MNI::DataDir::dir("mni_autoreg"),
                      # 'AnimalNLRegModel' => "icbm_avg_152_t1_tal_nlin_symmetric_VI"
                    },
                    'icbm152lin' => {
                      'RegLinDir'        => MNI::DataDir::dir("mni_autoreg"),
                      'RegLinModel'      => "icbm_avg_152_t1_tal_lin_symmetric",
                      'RegNLDir'         => MNI::DataDir::dir("mni_autoreg"),
                      'RegNLModel'       => "icbm_avg_152_t1_tal_lin_symmetric",
                      'TemplateDir'      => MNI::DataDir::dir("ICBM"),
                      'TemplateModel'    => "icbm_template",
                      'SurfaceMaskDir'   => MNI::DataDir::dir("mni_autoreg"),
                      'SurfaceMask'      => "icbm_avg_152_t1_tal_lin_symmetric_mask.obj",
                      'SurfRegModelDir'  => "$FindBin::Bin/models",
                      'SurfRegModel'     => "surf_reg_model_left.obj",
                      'SurfRegDataTerm'  => "surf_reg_model_left.txt",
                      'TagFileDir'       => MNI::DataDir::dir("classify"),
                      'TagFile'          => "n/a",
                      'AnimalAtlas'      => "-symmetric_atlas",
                      'AnimalNLRegDir'   => MNI::DataDir::dir("mni_autoreg"),
                      'AnimalNLRegModel' => "icbm_avg_152_t1_tal_lin_symmetric"
                    }
                  );

############# The status report filename:
my $statusReportFile = "CIVET_status_report.csv";

############# Options for how CIVET is to be run: the default will be to run
############# t1 data, cleaning tags, ANIMAL, the production of 82k 
############# polygon surfaces, no symmetry stages, and surface registration. 
my $inputType = "t1only";
my $correctPVE = 0;
my $maskType = "t1only";
my $interpMethod = "trilinear";
my $N3Distance = 200;
my $lsqtype = "-lsq9";
my $VBM_fwhm = 10;
my $VBM_symmetry = "noSymmetry";
my $VBM_cerebellum = "Cerebellum";
my $animal = "noANIMAL";
my $surface = "SURFACE";
my @thickness = ("tlink","20");

############# Some directories that the user will need to specify
my $sourceDir = undef;
my $target = undef;
my $prefix = undef;
my $sourceSubDir = "noIdSubDir";
my $idTextFile = undef;

############# Options table
my @leftOverArgs;
my @argTbl = (
          ["Execution control", "section"],
          ["-spawn", "const", "spawn", \$PMPtype, "Use the perl system interface to spawn jobs"],
          ["-sge", "const", "sge", \$PMPtype, "Use SGE to spawn jobs."],
          ["-pbs", "const", "pbs", \$PMPtype, "Use PBS to spawn jobs"],
          ["-queue", "string", 1, \$PMPconf{$PMPtype}{queue}, "Which queue to use"],
          ["-hosts", "string", 1, \$PMPconf{$PMPtype}{hosts}, "Colon separated list of hosts"],
          ["-qopts", "string", 1, \$PMPconf{$PMPtype}{opts}, "Extra options to queuing system"],
          ["-no-granular|-granular", "boolean", 1, \$PMPgranularity, 
           "Granularity level for submission of jobs using queueing system."],
          ["-maxqueued", "string", 1, \$PMPmaxQueued, 
           "Maximum number of jobs that can be submitted at once."],

          ["File options", "section"],
          ["-sourcedir", "string", 1, \$sourceDir, "Directory containing the source files."],
          ["-targetdir", "string", 1, \$target, "Directory where processed data will be placed."],
          ["-prefix", "string", 1, \$prefix, "File prefix to be used in naming output files."],
          ["-id-subdir", "const", "IdSubDir", \$sourceSubDir, "Indicate that the source directory contains sub-directories for each id"],
          ["-id-file", "string", 1, \$idTextFile, "A text file that contains all the subject id\'s (separated by space, tab, return or comma) that CIVET will run on."],

          ["Pipeline options", "section"],
          ["-template", "string", 1, \$TemplateSize, 
           "Define the template for image processing in stereotaxic space (0.50, 0.75, 1.00, 1.50, 2.00, 3.00, 4.00, 6.00)."],
          ["-model", "string", 1, \$CIVETModel,
           "Define the model for image-processing (icbm152nl or icbm152lin)"],

          ["CIVET options", "section"],  
          ["-multispectral", "const", "multispectral", \$inputType, 
           "Use T1, T2 and PD native files for tissue classification."],
          ["-correct-pve|-no-correct-pve", "boolean", 1, \$correctPVE, 
           "Apply correction to the mean and variance of tissue types at pve iterations."],
          ["-spectral_mask", "const", "multispectral", \$maskType, 
           "Use T1, T2 and PD native files for brain masking."],
          ["-interp", "string", 1, \$interpMethod,
           "Interpolation method from native to stereotaxic space (\"trilinear\", \"tricubic\", \"sinc\""],
          ["-N3-distance", "string", 1, \$N3Distance, 
           "N3 spline distance in mm (suggested values: 200 for 1.5T scan; 25 for 3T scan)."],
          ["-lsq6", "const", "-lsq6", \$lsqtype,
           "use 6-parameter transformation for linear registration [default -lsq9]" ],
          ["-lsq12", "const", "-lsq12", \$lsqtype,
           "use 12-parameter transformation for linear registration [default -lsq9]" ],
          ["-no-surfaces", "const", "noSURFACE", \$surface, "don\'t build surfaces"],
          ["-hi-res-surfaces", "const", "hiResSURFACE", \$surface, 
           "build high resolution surfaces"],
          ["-animal", "const", "ANIMAL", \$animal, 
           "run volumetric ANIMAL segmentation and cortical surface lobe parcellation [default -no-animal]"],
          ["-no-animal", "const", "noANIMAL", \$animal, 
           "don\'t run volumetric ANIMAL segmentation and cortical surface lobe parcellation."],
          ["-thickness", "string", 2, \@thickness,
           "compute cortical thickness and blur [tlink|tlaplace|tnear|tnormal] [kernel size in mm]"],

          ["VBM options", "section"],  
          ["-VBM-fwhm", "string", 1, \$VBM_fwhm, 
           "blurring kernel size in mm for volume"],
          ["-VBM-symmetry", "const", "Symmetry", \$VBM_symmetry, 
           "run symmetry tools [default -no-VBM-symmetry]"],
          ["-no-VBM-symmetry", "const", "noSymmetry", \$VBM_symmetry, 
           "don\'t run symmetry tools"],
          ["-VBM-cerebellum", "const", "Cerebellum", \$VBM_cerebellum, 
           "keep cerebellum in VBM maps"],
          ["-no-VBM-cerebellum", "const", "noCerebellum", \$VBM_cerebellum, 
           "mask out cerebellum in VBM maps [default -VBM-cerebellum]"],

          ["Pipeline control", "section"],
          ["-run", "const", "run", \$command, "Run the pipeline."],
          ["-status-from-files", "const", "statusFromFiles", \$command, "Compute pipeline status from files"],
          ["-print-stages", "const", "printStages", \$command, "Print the pipeline stages."],
          ["-print-status", "const", "printStatus", \$command, "Print the status of each pipeline."],
          ["-make-graph", "const", "makeGraph", \$command, "Create dot graph file."],
          ["-make-filename-graph", "const", "makeFilenameGraph", \$command, "Create dot graph of filenames."],
          ["-print-status-report", "const", "printStatusReport", \$command, "Writes a CSV status report to file in cwd."],

          ["Stage Control", "section"],
          ["-reset-all", "const", "resetAll", \$reset, "Start the pipeline from the beginning."],
          ["-reset-from", "string", 1, \$reset, "Restart from the specified stage."],
          ["-reset-running|-no-reset-running", "boolean", 1, \$resetRunning, "Restart currently running jobs."],
          );

GetOptions(\@argTbl, \@ARGV, \@leftOverArgs) or die "\n";


############# Basic usage
my @dsids;

if ($idTextFile) {
    open (IDTEXTFILE, "$idTextFile") or die ("Cannot open '$idTextFile': $!");
    # read the whole text file into one string
    my $idstext = "";
    while (my $idline = <IDTEXTFILE>) {
    $idstext .= $idline;
    }
    close (IDTEXTFILE) or die ("Cannot close '$idTextFile': $!");
    # split the string on whitespace (\s) or comma
    @dsids = split(/[\s,]+/, $idstext);
} 
else {
    @dsids = @leftOverArgs or die $usage;
}

unless ($prefix && $target && $sourceDir) {
    die "\n\n*******ERROR********: \n     You must specify -prefix, -targetdir, and -sourcedir \n********************\n\n\n";
}
$target =~ s#/+$##;      # remove trailing / at end of directory name, if any
$target = abs_path( $target );
$sourceDir = abs_path( $sourceDir );


############# Set no file buffering for stdout (buffer is printed every 1 line)
$| = 1;

############# Print the CIVET options list and related error messages
my $DATE = `date`;
chomp( $DATE );
my $UNAME = `uname -s -n -r`;
chomp( $UNAME );
print "\n\n* Pipeline started at $DATE on $UNAME \n";
print "\n* This is CIVET $version, $versionDate \n";
print "\n* CIVET Command line is:\n       $0 @ARGV \n";
print "\n* The source directory is: '$sourceDir' \n";
print "* The target directory is: '$target' \n";
print "* The prefix is: '$prefix' \n";
print "* The PMP class is: '$PMPtype' \n";
print "* The $PMPtype queue type is: '$PMPconf{$PMPtype}{queue}' \n";
print "* The $PMPtype batch host(s) is/are: '$PMPconf{$PMPtype}{hosts}' \n";
print "* The $PMPtype global options are: '$PMPconf{$PMPtype}{opts}' \n";

############# The -like template (0.50, 0.75, 1.00, 1.50, 2.00, 3.00, 4.00, 6.00)

my $Template = "$CIVETmodels{$CIVETModel}{TemplateDir}/" .
               "$CIVETmodels{$CIVETModel}{TemplateModel}_${TemplateSize}mm.mnc";
print "* Template for image-processing is:\n  $Template \n";

############# Define registration targets and directories and print them

print "* Using $CIVETModel model for data-processing pipeline:\n";

my $regLinModelDir = $CIVETmodels{$CIVETModel}{RegLinDir};
my $regNLModelDir = $CIVETmodels{$CIVETModel}{RegNLDir};

print "* Registration linear model directory is:    \n  $regLinModelDir \n";
print "* Registration non-linear model directory is:\n  $regNLModelDir \n";

my $regLinModel = $CIVETmodels{$CIVETModel}{RegLinModel};
my $regNLModel = $CIVETmodels{$CIVETModel}{RegNLModel};

print "* Registration linear model is:    \n   $regLinModel \n";
print "* Registration non-linear model is:\n   $regNLModel \n";

############# Define intermediate registration targets and directories and print them
my $intermediate_model = undef;

############# Define Surface registration targets and directories and print them

my $SurfRegModelDir = $CIVETmodels{$CIVETModel}{SurfRegModelDir};
my $SurfRegModel = $CIVETmodels{$CIVETModel}{SurfRegModel};
my $SurfRegDataTerm = $CIVETmodels{$CIVETModel}{SurfRegDataTerm};

print "* Surface registration model directory is: \n  ${SurfRegModelDir} \n";
print "* Surface registration model is:    \n   ${SurfRegModel} \n";
print "* Surface registration dataterm is: \n   ${SurfRegDataTerm} \n";

############# Define Surface registration targets and directories and print them

my $AnimalNLRegDir = $CIVETmodels{$CIVETModel}{AnimalNLRegDir};
my $AnimalNLRegModel = $CIVETmodels{$CIVETModel}{AnimalNLRegModel};

if( $animal eq "ANIMAL" ) {
  print "* ANIMAL non-linear registration model directory is: \n  ${AnimalNLRegDir} \n";
  print "* ANIMAL non-linear registration model is:    \n   ${AnimalNLRegModel} \n";
  print "\n";
  print "*             -WARNING- -WARNING- -WARNING-\n\n";
  print "* We recommend that you no longer use the ANIMAL segmentation in CIVET\n";
  print "* until the new lobe segmentation based on the iterative non-linear \n";
  print "* ICBM152 model is fully validated and released. Current results based\n";
  print "* on the linear symmetric model are inaccurate and should not be used.\n";
}


############# Print the Pipeline and Stage Control commands

if( !($command eq "run") ) {
	$resetRunning = 0;
}
print "\n\n* Pipeline Control command is: '$command'";
	
if ($reset and $resetRunning ne 0){
    print "\n* Stage control commands are: '$reset' and 'reset-running'";
}
elsif ($reset and $resetRunning eq 0){
    print "\n* Stage control commands are: '$reset' and 'no-reset-running'";
}

print "\n\n\n* Data-set Subject ID(s) is/are: '@dsids'\n\n\n";

my $second_model_dir = "$FindBin::Bin/models";

system("mkdir -p ${target}") if (! -d ${target});


############# An array to store the pipeline definitions for each subject
my $pipes = PMP::Array->new();

#########################################################
# Set up the pipeline output directories for each subject
#########################################################
foreach my $dsid (@dsids) {

    ##### Create image object. #####

    # depending on the two options your files can be in on target
    # or there can be subdirs for every subject
    my $Source_Base;
    if ($sourceSubDir eq "noIdSubDir") {
      $Source_Base = "${sourceDir}/";
    } else {
      $Source_Base = "${sourceDir}/${dsid}/";
    }

    my $image = MRI_Image->new( $Source_Base,
                                $target,
                                $prefix,
                                $dsid,
                                $inputType,
                                $correctPVE,
                                $maskType,
                                $interpMethod,
                                $N3Distance,
                                $lsqtype,
                                $surface,
                                $animal,
                                \@thickness,
                                $Template,
                                \$CIVETmodels{$CIVETModel} );

    ##### Add VBM fields to hash table MRI_Image #####

    $image->{VBM_fwhm} = $VBM_fwhm;
    $image->{VBM_symmetry} = $VBM_symmetry;
    $image->{VBM_cerebellum} = $VBM_cerebellum;
    my $VBM_Dir = "${target}/${dsid}/VBM";
    system( "mkdir -p ${VBM_Dir}" ) if( ! -d "${VBM_Dir}" );
    $image->{VBM_cls_masked} = "${VBM_Dir}/${prefix}_${dsid}_cls_masked.mnc";
    $image->{VBM_smooth_wm} = "${VBM_Dir}/${prefix}_${dsid}_smooth_${VBM_fwhm}_wm.mnc";
    $image->{VBM_smooth_gm} = "${VBM_Dir}/${prefix}_${dsid}_smooth_${VBM_fwhm}_gm.mnc";
    $image->{VBM_smooth_csf} = "${VBM_Dir}/${prefix}_${dsid}_smooth_${VBM_fwhm}_csf.mnc";
    $image->{VBM_smooth_wm_sym} = "${VBM_Dir}/${prefix}_${dsid}_smooth_${VBM_fwhm}_wm_sym.mnc";
    $image->{VBM_smooth_gm_sym} = "${VBM_Dir}/${prefix}_${dsid}_smooth_${VBM_fwhm}_gm_sym.mnc";
    $image->{VBM_smooth_csf_sym} = "${VBM_Dir}/${prefix}_${dsid}_smooth_${VBM_fwhm}_csf_sym.mnc";

    ##### Create the pipeline environment. #####

    my $pipeline;

    if ($PMPtype eq "spawn") {
        $pipeline = PMP::spawn->new();
        $PMPgranularity = 0;
    } elsif ($PMPtype eq "sge") {
        $pipeline = PMP::sge->new();
        $pipeline->setQueue($PMPconf{$PMPtype}{queue});
        $pipeline->setHosts($PMPconf{$PMPtype}{hosts}) if( defined $PMPconf{$PMPtype}{hosts} );
        $pipeline->setQueueOptions($PMPconf{$PMPtype}{opts}) if( defined $PMPconf{$PMPtype}{opts} );
	$pipeline->setPriorityScheme("later-stages");
    } elsif ($PMPtype eq "pbs") {
        $pipeline = PMP::pbs->new();
        $pipeline->setQueue($PMPconf{$PMPtype}{queue});
        $pipeline->setHosts($PMPconf{$PMPtype}{hosts}) if( defined $PMPconf{$PMPtype}{hosts} );
        $pipeline->setQueueOptions($PMPconf{$PMPtype}{opts}) if( defined $PMPconf{$PMPtype}{opts} );
        $pipeline->setPriorityScheme("later-stages");
    }

    # set some generic pipeline options
    $pipeline->name($dsid);
    $pipeline->debug(0);
    $pipeline->statusDir("${target}/${dsid}/logs");
    
##################################### ################# #################
# This used to be the definition of stages... Now it is in modules       
##################################### ################# #################

    VBM_Main::create_pipeline( \$pipeline,
                               undef,
                               \$image,
                               );    

####################################################################################
# Pipeline management
####################################################################################

############# Set the status of the stages.

    if ($reset && ($reset eq "resetAll") ) {
        # Restart all stages
        $pipeline->resetAll();
    } else {
        # restart from a given stage;
        $pipeline->resetFromStage($reset) if( $reset );
        # Rerun any failures from a previous run of this subjects pipe
        $pipeline->resetFailures();
        # Reset running jobs if that's what the user wants.
        $pipeline->resetRunning() if ($resetRunning);
    }

    $pipeline->updateStatus();
 
############# Add this pipe to our happy array of pipes
    
    $pipes->addPipe($pipeline);
    
} ####################################### end of foreach


############# Now run whatever it is that the user wanted done

if ($command eq "printStatus" ) {
    $pipes->printUnfinished();
}

elsif ($command eq "printStatusReport") {
    $pipes->printStatusReport($statusReportFile);
}

elsif ($command eq "statusFromFiles") {
    $pipes->updateFromFiles();
    $pipes->printUnfinished();
}

elsif ($command eq "printStages") {
    $pipes->printStages();
}

elsif ($command eq "makeGraph") {
    $pipes->createDotGraph("dependency-graph.dot");
}

elsif ($command eq "makeFilenameGraph") {
    $pipes->createFilenameDotGraph("filename-dependency-graph.dot","${target}/$dsids[0]/");
}

elsif ($command eq "run") { 
    # register all the programs
    $pipes->registerPrograms();
    $pipes->maxQueued($PMPmaxQueued);
    $pipes->setGranularity($PMPgranularity);
    $pipes->run();
}

else {
    print "huh? Grunkle little gnu, grunkle\n";
}

############# Voila!! #############

# Set interrupt handler (for cleaning of lock files)

sub CLEANUP {
  print "\nCaught signal - cleaning up all lock files\n\n";
  $pipes->cleanup();
  exit(1);
}

