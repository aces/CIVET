#! /usr/bin/env perl

############################################################################
############################################################################
### Post-processing module to the CIVET pipeline to perform basic
### quality control.
###                                       
###   Authors: Claude Lepage
###            September, 2014
###
###         Copyright Alan C. Evans
###         Professor of Neurology
###         McGill University
###
### For more information, have a look at our documentation at:
###    http://wiki.bic.mni.mcgill.ca/index.php/CIVET
###                                 
############################################################################
############################################################################

use strict;
use FindBin;
use Cwd qw( abs_path );
use Env qw( PATH );
use List::Util qw( min max );
use File::Temp qw/ tempdir /;
use File::Basename;

# All modules that will be used in either case are declared here
use Getopt::Tabular;
use MNI::Startup;
use MNI::PathUtilities qw(split_path);
use MNI::FileUtilities qw(check_output_dirs check_output_path);
use MNI::DataDir;

use lib "$FindBin::Bin";
use MRI_Image;

$PATH = "$FindBin::Bin/progs:${PATH}";

# Set interrupt handler (for cleaning of lock files)
$SIG{'INT'} = 'CLEANUP';
$SIG{'TERM'} = 'CLEANUP';

# Create tmp dir.
my $tmpdir = tempdir( CLEANUP => 1 );

my $version = "2.0.0";
my $versionDate= "September, 2014";
my $authors= "Claude Lepage";
my $usage = "\nUSAGE:\n$ProgramName -targetdir <dir> -prefix <prefix> [options] id1 id2 ... idn > <logfile>\n 
ALTERNATIVE USAGE:\n
$ProgramName -targetdir <dir> -prefix <prefix> -id-file <idfile> [options]  > <logfile>\n\n";

my $whatsnew = <<NEW;
    *************************************************************************
    New in $versionDate quarantine, version $version

    1 - Re-organization of the QC info to make it independent of CIVET versions
        going onwards. The info is parsed from one global file produced by CIVET.
        The parsing is very fast and can be done interactively.

    *************************************************************************
    New in Nov-2010 quarantine, version 1.1.11

    1 - Initial implementation

    More to come soon:

    *************************************************************************
NEW

my $help = <<HELP;

$ProgramName, version $version, released $versionDate.
    Released by $authors.

    Basic quality control for CIVET output.

$whatsnew
HELP
Getopt::Tabular::SetHelp($help, $usage);


############# Some directories that the user will need to specify
my $source = undef;   ## now obsolete
my $target = undef;
my $prefix = undef;
my $idTextFile = undef;

############# Options table
my @leftOverArgs;
my @argTbl = (
          ["File options", "section"],
          ["-sourcedir", "string", 1, \$source, "obsolete parameter.", "<dir>"],
          ["-targetdir", "string", 1, \$target, "Directory where processed data will be placed.", "<dir>"],
          ["-prefix", "string", 1, \$prefix, "File prefix to be used in naming output files.", "<prefix>"],
          ["-id-file", "string", 1, \$idTextFile, "A text file that contains all the subject id\'s (separated by space, tab, return or comma) that CIVET will run on.", "<file>"],
          );

GetOptions(\@argTbl, \@ARGV, \@leftOverArgs) or die "\n";


############# Basic usage
my @dsids;
my @long_dsids;

if ($idTextFile) {
    open (IDTEXTFILE, "$idTextFile") or die ("Cannot open '$idTextFile': $!");
    # read the whole text file into one string
    my $idstext = "";
    while (my $idline = <IDTEXTFILE>) {
      $idstext .= $idline;
    }
    close (IDTEXTFILE) or die ("Cannot close '$idTextFile': $!");
    # split the string on whitespace (\s) or comma
    @long_dsids = split(/[\s,]+/, $idstext);
} else {
    @long_dsids = @leftOverArgs or die $usage;
}

for my $id (@long_dsids) {
  push @dsids, split( /:/, $id );
}

unless ($prefix && $target) {
    die "\n\n" .
        "*************************** ERROR ****************************: \n" .
        "     You must specify -prefix and -targetdir \n" .
        "**************************************************************\n\n\n";
}
$target =~ s#/+$##;      # remove trailing / at end of directory name, if any
$target = abs_path( $target );

############# Set no file buffering for stdout (buffer is printed every 1 line)
$| = 1;

############# Print the CIVET options list and related error messages
my $DATE = `date`;
chomp( $DATE );
my $UNAME = `uname -s -n -r`;
chomp( $UNAME );
print "\n\n* Pipeline started at $DATE on $UNAME \n";
print "\n* This is CIVET $version, $versionDate \n";
print "\n* CIVET Command line is:\n       $0 @ARGV \n";
print "* The target directory is: '$target' \n";
print "* The prefix is: '$prefix' \n";

print "\n\n\n* Data-set Subject ID(s) is/are: '@dsids'\n\n\n";

my $qc_dir = "${target}/QC";
system("mkdir -p $qc_dir") if (! -d $qc_dir );

#########################################################
# Define the tags of interest for the QC.
#########################################################

my $Qc_good = 0;
my $Qc_warning = 1;
my $Qc_danger = 2;
my $Qc_incomplete = 3;
my $Qc_local = 4;
my @QcColours = ( "lightgreen", "orange", "red", "yellow", "pink" );
my @QcFactor = ( 0, 1, 2, 5, 1 );

my @fields = ( { 'name' => 'XSTEP',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_voxel_size,
                 'title' => "x-voxel size in native space (mm)",
                 'xlabel' => "Subjects",
                 'ylabel' => "x-size (mm)",
                 'format' => "%5.2f",
                 'caption' => "x-voxel size in native space." },
               { 'name' => 'YSTEP',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_voxel_size,
                 'title' => "y-voxel size in native space (mm)",
                 'xlabel' => "Subjects",
                 'ylabel' => "y-size (mm)",
                 'format' => "%5.2f",
                 'caption' => "y-voxel size in native space." },
               { 'name' => 'ZSTEP',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_voxel_size,
                 'title' => "z-voxel size in native space (mm)",
                 'xlabel' => "Subjects",
                 'ylabel' => "z-size (mm)",
                 'format' => "%5.2f",
                 'caption' => "z-voxel size in native space." },
               { 'name' => 'MASK_ERROR',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_above,
                 'title' => "Stereotaxic brain mask error (%)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Error %",
                 'format' => "%5.2f",
                 'caption' => "Brain mask error in stereotaxic space." },
               { 'name' => 'WM_PERCENT',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Percentage of the classified WM in the brain (masked)",
                 'xlabel' => "Subjects",
                 'ylabel' => "WM %",
                 'format' => "%5.2f",
                 'caption' => "Percentage of the classified WM in the brain (masked)." },
               { 'name' => 'GM_PERCENT',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Percentage of the classified GM in the brain (masked)",
                 'xlabel' => "Subjects",
                 'ylabel' => "GM %",
                 'format' => "%5.2f",
                 'caption' => "Percentage of the classified GM in the brain (masked)." },
               { 'name' => 'CSF_PERCENT',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Percentage of the classified CSF in the brain (masked)",
                 'xlabel' => "Subjects",
                 'ylabel' => "CSF %",
                 'format' => "%5.2f",
                 'caption' => "Percentage of the classified CSF in the brain (masked)." },
               { 'name' => 'BRAIN_VOL',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Total brain volume (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%6.2f",
                 'caption' => "Total brain volume including cerebrum, cerebellum and brainstem." },
               { 'name' => 'CEREBRUM_VOL',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Cerebrum volume (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%6.2f",
                 'caption' => "Volume of the cerebrum only (should equal CORTICAL_GM + WHITE_VOL + SUBGM_VOL + CSF_VENT_VOL)." },
               { 'name' => 'CORTICAL_GM',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Volume of Cortical GM (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%6.2f",
                 'caption' => "Volume of the cortical GM only." },
               { 'name' => 'WHITE_VOL',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Volume of classified WM (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%6.2f",
                 'caption' => "Volume of the WM inside the cerebrum." },
               { 'name' => 'SUBGM_VOL',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Volume of sub-cortical GM (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%6.2f",
                 'caption' => "Volume of the sub-cortical GM inside the cerebrum." },
               { 'name' => 'CSF_VENT_VOL',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Volume of the ventricles (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%6.2f",
                 'caption' => "Volume of the ventricles (CSF) inside the cerebrum." },
               { 'name' => 'GI_LEFT',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => undef,
                 'title' => "Gyrification index for left pial surface",
                 'xlabel' => "Subjects",
                 'ylabel' => "GI",
                 'format' => "%5.3f",
                 'caption' => "Gyrification index for left pial surface." },
               { 'name' => 'GI_RIGHT',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => undef,
                 'title' => "Gyrification index for right pial surface",
                 'xlabel' => "Subjects",
                 'ylabel' => "GI",
                 'format' => "%5.3f",
                 'caption' => "Gyrification index for right pial surface." },
               { 'name' => 'LEFT_INTER',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_intersections,,
                 'title' => "Number of self-intersections in resampled left mid surface",
                 'xlabel' => "Subjects",
                 'ylabel' => "Number of self-intersections",
                 'format' => "%4d",
                 'caption' => "Number of self-intersections in resampled left mid surface as a result of surface registration." },
               { 'name' => 'RIGHT_INTER',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_intersections,,
                 'title' => "Number of self-intersections in resampled right mid surface",
                 'xlabel' => "Subjects",
                 'ylabel' => "Number of self-intersections",
                 'format' => "%4d",
                 'caption' => "Number of self-intersections in resampled right mid surface as a result of surface registration." },
               { 'name' => 'LEFT_SURF_SURF',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_intersections,,
                 'title' => "Number of surface-surface intersections between left wm-gm surfaces",
                 'xlabel' => "Subjects",
                 'ylabel' => "Number of intersections",
                 'format' => "%4d",
                 'caption' => "Number of surface-surface intersections between left wm-gm surfaces." },
               { 'name' => 'RIGHT_SURF_SURF',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_intersections,,
                 'title' => "Number of surface-surface intersections between right wm-gm surfaces",
                 'xlabel' => "Subjects",
                 'ylabel' => "Number of intersections",
                 'format' => "%4d",
                 'caption' => "Number of surface-surface intersections between right wm-gm surfaces." },
               { 'name' => 'LAPLACIAN_MIN',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_laplacian_min,
                 'title' => "Minimum Laplacian value in gray surface convergence",
                 'xlabel' => "Subjects",
                 'ylabel' => "Laplacian value",
                 'format' => "%5.3f",
                 'caption' => "Minimum Laplacian value in gray surface convergence (should be close to 10)." },
               { 'name' => 'LAPLACIAN_MAX',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_laplacian_max,
                 'title' => "Maximum Laplacian value in gray surface convergence",
                 'xlabel' => "Subjects",
                 'ylabel' => "Laplacian value",
                 'format' => "%5.3f",
                 'caption' => "Maximum Laplacian value in gray surface convergence (should be close to 10)." },
               { 'name' => 'LAPLACIAN_MEAN',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_laplacian_mean,
                 'title' => "Mean Laplacian value in gray surface convergence",
                 'xlabel' => "Subjects",
                 'ylabel' => "Laplacian value",
                 'format' => "%5.3f",
                 'caption' => "Mean Laplacian value in gray surface convergence (should be close to 10)." },
               ## ANIMAL Lobar Segmentation
               { 'name' => 'ANIMAL_2',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM parietal (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM parietal (right)." },
               { 'name' => 'ANIMAL_6',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM parietal (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM parietal (left)." },
               { 'name' => 'ANIMAL_105',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM parietal (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM parietal (right)." },
               { 'name' => 'ANIMAL_57',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM parietal (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM parietal (left)." },
               { 'name' => 'ANIMAL_219',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM temporal (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM temporal (right)." },
               { 'name' => 'ANIMAL_218',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM temporal (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM temporal (left)." },
               { 'name' => 'ANIMAL_59',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM temporal (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM temporal (right)." },
               { 'name' => 'ANIMAL_83',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM temporal (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM temporal (left)." },
               { 'name' => 'ANIMAL_211',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM frontal (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM frontal (right)." },
               { 'name' => 'ANIMAL_210',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM frontal (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM frontal (left)." },
               { 'name' => 'ANIMAL_17',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM frontal (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM frontal (right)." },
               { 'name' => 'ANIMAL_30',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM frontal (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM frontal (left)." },
               { 'name' => 'ANIMAL_4',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM occipital (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM occipital (right)." },
               { 'name' => 'ANIMAL_8',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "GM occipital (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of GM occipital (left)." },
               { 'name' => 'ANIMAL_45',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM occipital (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM occipital (right)." },
               { 'name' => 'ANIMAL_73',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "WM occipital (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of WM occipital (left)." },
               { 'name' => 'ANIMAL_76',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Cerebellum (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of cerebellum (right)." },
               { 'name' => 'ANIMAL_67',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Cerebellum (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of cerebellum (left)." },
               { 'name' => 'ANIMAL_20',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Brainstem (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of brainstem." },
               { 'name' => 'ANIMAL_53',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Caudate (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of caudate (right)." },
               { 'name' => 'ANIMAL_39',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Caudate (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of caudate (left)." },
               { 'name' => 'ANIMAL_16',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Putamen (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of putamen (right)." },
               { 'name' => 'ANIMAL_14',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Putamen (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of putamen (left)." },
               { 'name' => 'ANIMAL_203',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Thalamus (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of thalamus (right)." },
               { 'name' => 'ANIMAL_102',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Thalamus (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of thalamus (left)." },
               { 'name' => 'ANIMAL_23',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Subthalamic nucleus (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of subthalamic nucleus (right)." },
               { 'name' => 'ANIMAL_33',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Subthalamic nucleus (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of subthalamic nucleus (left)." },
               { 'name' => 'ANIMAL_11',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Globus pallidus (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of globus pallidus (right)." },
               { 'name' => 'ANIMAL_12',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Globus pallidus (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of globus pallidus (left)." },
               { 'name' => 'ANIMAL_254',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Fornix (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of fornix (right)." },
               { 'name' => 'ANIMAL_29',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Fornix (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of fornix (left)." },
               { 'name' => 'ANIMAL_9',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Lateral ventricle (right) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of lateral ventricle (right)." },
               { 'name' => 'ANIMAL_3',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Lateral ventricle (left) (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of lateral ventricle (left)." },
               { 'name' => 'ANIMAL_232',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "3rd ventricle (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of 3rd ventricle." },
               { 'name' => 'ANIMAL_233',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "4th ventricle (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of 4th ventricle." },
               { 'name' => 'ANIMAL_255',
                 'mean' => 0,
                 'stdev' => 0,
                 'stdev_long' => 0,
                 'count' => 0,
                 'function' => \&check_stdev_centered,
                 'title' => "Extracerebral CSF (cc)",
                 'xlabel' => "Subjects",
                 'ylabel' => "Volume (cc)",
                 'format' => "%5.2f",
                 'caption' => "Volume (cc) of extracerebral CSF." },
               );

#########################################################
# Collect data for each subject.
#########################################################

# On the first pass, compute the mean and stdev only in order to use
# these values in the auto-QC.

print "Computing mean and stdev for all fields...\n";

foreach my $id (@long_dsids) {

  my @local_dsids = split( /:/, $id );

  my @subject_count = ();
  my @subject_sum = ();
  for( my $j = 0; $j <= $#fields; $j++ ) {
    $subject_count[$j] = 0;
    $subject_sum[$j] = 0;
  }

  foreach my $dsid (@local_dsids) {

    my $civet_qc_file = "${target}/${dsid}/verify/${prefix}_${dsid}_civet_qc.txt";
    if( -e $civet_qc_file ) {
      my %list = &parse_qc_file( $civet_qc_file );

      for( my $j = 0; $j <= $#fields; $j++ ) {
        my $key = $fields[$j]{name};
        if( defined( $list{$key} ) ) {
          # Contribution to the mean and stdev for this field.
          $subject_count[$j]++;
          $subject_sum[$j] += $list{$key};
          $fields[$j]{count}++;
          $fields[$j]{mean} += $list{$key};
          $fields[$j]{stdev} += $list{$key} * $list{$key};
        }
      }
    }
  }
  for( my $j = 0; $j <= $#fields; $j++ ) {
    if( $subject_count[$j] > 0 ) {
      $fields[$j]{stdev_long} += $subject_sum[$j] * $subject_sum[$j] / $subject_count[$j];
    }
  }
}

#########################################################
# Compute the global mean and stdev for each field 
# (normalization step).
#########################################################

for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    $fields[$j]{stdev_long} = sqrt( abs( $fields[$j]{stdev} - $fields[$j]{stdev_long} ) /
                                    $fields[$j]{count} );
    $fields[$j]{mean} /= $fields[$j]{count};
    $fields[$j]{stdev} = sqrt( abs( $fields[$j]{stdev} / $fields[$j]{count} -
                                    $fields[$j]{mean} * $fields[$j]{mean} ) );
  }
}

#########################################################
# Create html and csv tables.
#########################################################

print "Creating html table for all data...\n";

my @colours = ( "#aabbbb", "#eeeedd", "#cccccc", "#aabbaa", "#dddddd" );
my $ncolours = 5;

#########################################################
# Header line for html document.
#########################################################

my $html = "<h1> CIVET PIPELINE QUALITY CONTROL</h1>\n";
$html .= "<table cellspacing=\"2\" bgcolor=\"white\">\n";
$html .= "<tr bgcolor=\"\#cccccc\">" .
         "<th>No.</th>" .
         "<th>ID</th>";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    $html .= "<th>$fields[$j]{name}</th>";
  }
}
$html .= "</tr>\n";

#########################################################
# Header line for csv file.
#########################################################

my $csv = "ID,";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    $csv .= "$fields[$j]{name}";
    $csv .= "," if( $j < $#fields );
  }
}
$csv .= "\n";

my $count = 0;
my $group = -1;
foreach my $id (@long_dsids) {

  $group++;
  my @local_dsids = split( /:/, $id );

  # Recompute the local means for this longitudinal group of visits.

  my @subject_count = ();
  my @subject_mean = ();
  for( my $j = 0; $j <= $#fields; $j++ ) {
    $subject_count[$j] = 0;
    $subject_mean[$j] = 0;
  }
  foreach my $dsid (@local_dsids) {
    my $civet_qc_file = "${target}/${dsid}/verify/${prefix}_${dsid}_civet_qc.txt";
    my %list = ( -e $civet_qc_file ) ? &parse_qc_file( $civet_qc_file ) : undef;
    for( my $j = 0; $j <= $#fields; $j++ ) {
      if( $fields[$j]{count} > 0 ) {
        my $key = $fields[$j]{name};
        if( defined( $list{$key} ) ) {
          # Contribution to the local mean for this field.
          $subject_count[$j]++;
          $subject_mean[$j] += $list{$key};
        }
      }
    }
  }
  for( my $j = 0; $j <= $#fields; $j++ ) {
    if( $subject_count[$j] > 0 ) {
      $subject_mean[$j] /= $subject_count[$j];
    }
  }

  # Now fill in the html and csv tables.

  foreach my $dsid (@local_dsids) {

    $count++;

    my $civet_qc_file = "${target}/${dsid}/verify/${prefix}_${dsid}_civet_qc.txt";
    my %list = ( -e $civet_qc_file ) ? &parse_qc_file( $civet_qc_file ) : undef;

    my $csvline = "${dsid},";
    my $htmlline = "";

    my $qc_code = 0;

    for( my $j = 0; $j <= $#fields; $j++ ) {
      if( $fields[$j]{count} > 0 ) {
        my $key = $fields[$j]{name};
        if( defined( $list{$key} ) ) {
          my $str = sprintf( $fields[$j]{format}, $list{$key} );
          $csvline .= "${str},";
          my $code = ( defined( $fields[$j]{function} ) ) ? 
                     $fields[$j]{function}->( $list{$key}, $fields[$j]{mean}, $fields[$j]{stdev} ) : 
                     $Qc_good;
          if( !$code ) {
            $code = ( defined( $fields[$j]{function} ) ) ? 
                      $fields[$j]{function}->( $list{$key}, $subject_mean[$j], 
                                               $fields[$j]{stdev_long} ) : 
                      $Qc_good;
            $code = $Qc_local if( $code );
          }
          if( $code ) {
            $qc_code += $QcFactor[$code];
            $htmlline .= "<td bgcolor=\"$QcColours[$code]\">" . $str . "</td> ";
          } else {
            $htmlline .= "<td>" . $str . "</td> ";
          }

        } else {
          $csvline .= ",";
          $htmlline .= "<td></td> ";
        }
      }
    }

    if( !(-e $civet_qc_file ) ) {
      $qc_code = $Qc_incomplete;
    } else {
      $qc_code = ( $qc_code > 1 ) ? ( $qc_code > 5 ? $Qc_danger : $Qc_warning ) : $Qc_good;
    }
    $htmlline = "<th bgcolor=\"$QcColours[$qc_code]\">" .
                "<a target=\"_blank\" href=\"${dsid}.html\">$dsid</a></th>" .
                $htmlline;

    ## This assumes that all results are the same for all subjects.

    my $options_file = "${target}/${dsid}/logs/${dsid}.options";
    die "Cannot file options file $options_file." if( !( -e $options_file ) );
    my ($thickness_options,$area_options,$volume_options) = parse_civet_options( $options_file, $version );

    $csvline .= "${dsid}/thickness/${prefix}_${dsid}_native_rms_rsl_@${thickness_options[0]}\_left.txt" .",";
    $csvline .= "${dsid}/thickness/${prefix}_${dsid}_native_rms_rsl_@${thickness_options[0]}\_right.txt" .",";
    $csvline .= "${dsid}/surfaces/${prefix}_${dsid}_mid_surface_rsl_left_native_area_@${area_options[0]}.txt" .",";
    $csvline .= "${dsid}/surfaces/${prefix}_${dsid}_mid_surface_rsl_right_native_area_@${area_options[0]}.txt" .",";
    $csvline .= "${dsid}/surfaces/${prefix}_${dsid}_surface_rsl_left_native_volume_@${volume_options[0]}.txt" .",";
    $csvline .= "${dsid}/surfaces/${prefix}_${dsid}_surface_rsl_right_native_volume_@${volume_options[0]}.txt" .",";
    $csvline .= "${dsid}/thickness/${prefix}_${dsid}_native_rms_rsl_@${thickness_options[0]}\_asym_hemi.txt";  # last line without a trailing comma

    $csvline .= "\n";
    $csv .= $csvline;

    $htmlline = "<tr bgcolor=\"$colours[$group%$ncolours]\">" . "<td>" . sprintf( "%4d", $count ) . 
                "</td>" .  $htmlline . "</tr>\n";
    $html .= $htmlline;

    open FILE, ">${qc_dir}/${dsid}.html";
    print FILE "<table>\n";
    print FILE "<tr><td><image src=\"../${dsid}/verify/${prefix}_${dsid}_verify.png\"></td></tr>\n";
    print FILE "<tr><td><image src=\"../${dsid}/verify/${prefix}_${dsid}_clasp.png\"></td></tr>\n";
    print FILE "<tr><td><image src=\"../${dsid}/verify/${prefix}_${dsid}_atlas.png\"></td></tr>\n";
    print FILE "<tr><td><image src=\"../${dsid}/verify/${prefix}_${dsid}_surfsurf.png\"></td></tr>\n";
    print FILE "<tr><td><image src=\"../${dsid}/verify/${prefix}_${dsid}_laplace.png\"></td></tr>\n";
    print FILE "</table>\n";
    close FILE;
  }
  ### $csv .= "\n";  ### blank line between longitudinal groups of scans???? 
}

#########################################################
# Save the table of data in csv format.
#########################################################

open FILE, ">${qc_dir}/civet_${prefix}.csv";
$csv =~ s/ +/ /g;
print FILE $csv;
close FILE;

#########################################################
# Footer line for mean and stdev of html document.
#########################################################

$html .= "<tr> </tr> ";
$html .= "<tr bgcolor=\"#dddddd\">" .
         "<th></th>" .
         "<th>N</th> ";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    my $str = sprintf( "%d", $fields[$j]{count} );
    $html .= "<th>$str</th>";
  }
}
$html .= "</tr>\n";

$html .= "<tr> </tr> ";
$html .= "<tr bgcolor=\"#dddddd\">" .
         "<th></th>" .
         "<th>Inter Mean</th> ";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    my $str = sprintf( $fields[$j]{format}, $fields[$j]{mean} );
    $html .= "<th>$str</th>";
  }
}
$html .= "</tr>\n";

$html .= "<tr> </tr> ";
$html .= "<tr bgcolor=\"#dddddd\">" .
         "<th></th>" .
         "<th>Inter StdDev</th> ";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    my $str = sprintf( $fields[$j]{format}, $fields[$j]{stdev} );
    $html .= "<th>$str</th>";
  }
}
$html .= "</tr>\n";

$html .= "<tr> </tr> ";
$html .= "<tr bgcolor=\"#dddddd\">" .
         "<th></th>" .
         "<th>Intra StdDev</th> ";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    my $str = sprintf( $fields[$j]{format}, $fields[$j]{stdev_long} );
    $html .= "<th>$str</th>";
  }
}
$html .= "</tr>\n";

$html .= "</table>";

#########################################################
# Print a legend for the symbols used.
#########################################################

$html .= "<h2> Legend of symbols</h2>\n";
$html .= "<table>\n";
for( my $j = 0; $j <= $#fields; $j++ ) {
  if( $fields[$j]{count} > 0 ) {
    my $key = $fields[$j]{name};
    $html .= "<tr> <td> $fields[$j]{name} </td> <td> $fields[$j]{title} </td></tr>\n";
  }
}
$html .= "</table>\n";

$html .= "<table>\n";
$html .= "<h2> Legend of colour codes</h2>\n";
$html .= "<tr><td bgcolor=\"$QcColours[$Qc_good]\"> Good </td></tr>\n";
$html .= "<tr><td bgcolor=\"$QcColours[$Qc_warning]\"> Warning (inter subject)</td></tr>\n";
$html .= "<tr><td bgcolor=\"$QcColours[$Qc_danger]\"> Severe warning, likely a processing error (inter subject)</td></tr>\n";
$html .= "<tr><td bgcolor=\"$QcColours[$Qc_local]\"> Warning on longitudinal QC (intra subject)</td></tr>\n";
$html .= "<tr><td bgcolor=\"$QcColours[$Qc_incomplete]\"> Incomplete result </td></tr>\n";
$html .= "</table>\n";

#########################################################
# Do some scatter plots of the various fields.
#########################################################

$html .= "<h2>Scatter plots of QC fields </h2>\n";
open FILE, ">${qc_dir}/civet_${prefix}.gnu";
print FILE "set datafile separator \",\"\n";

my $column = 1;   # skip dsid in .csv file

for( my $i = 0; $i <= $#fields; $i++ ) {
  if( $fields[$i]{count} > 0 ) {
    my $key = $fields[$i]{name};
    print "Processing field $key...\n";

    $column++;

    # Make the gnuplot graph for this field.

    print FILE "# $key\n";
    print FILE "clear\n";
    print FILE "set grid\n";
    print FILE "unset key\n";
    print FILE "set title \"$fields[$i]{title}\"\n";
    print FILE "set xlabel \"$fields[$i]{xlabel}\"\n";
    print FILE "set ylabel \"$fields[$i]{ylabel}\"\n";
    print FILE "set terminal png\n";
    print FILE "set output \"${qc_dir}/$key.png\"\n";
    print FILE "plot \"${qc_dir}/civet_${prefix}.csv\" u $column w lp, $fields[$i]{mean} w li 2, " .
               sprintf("%f",$fields[$i]{mean}-$fields[$i]{stdev}) . " w li 3, " .
               sprintf("%f",$fields[$i]{mean}+$fields[$i]{stdev}) . " w li 3\n";

    my $figure = $column - 1;
    $html .= "<table>\n" .
             "<tr> <td></td> <td> <img src=\"$key.png\"> </td></tr>\n" .
             "<tr> <td> Figure $figure: </td> <td> $fields[$i]{caption} </td></tr>\n" .
             "<tr> <td></td> <td>Green line is the mean; blue lines are mean +/- 1 stddev. </td></tr>";
             "</table>\n";
  }
}

close( FILE );
`gnuplot \< "${qc_dir}/civet_${prefix}.gnu"`;

open FILE, ">${qc_dir}/civet_${prefix}.html";
print FILE $html;
close FILE;

## All done!!

# Read a civet_qc file into a hash table.

sub parse_qc_file {

  my $input = shift;
  my %table = ();

  open( QC, $input );
  while( my $line = <QC> ) {
    chomp( $line );
    my ($key,$val) = split( '=', $line );
    $table{$key} = $val;
  }
  close( QC );
  return( %table );
}

# Read the civet options file to obtain processing information.

sub parse_civet_options {

  my $input = shift;
  my $version = shift;

  my @thickness_info = ();
  my @area_info = ();
  my @volume_info = ();
  
  open( OPTIONS, $input );

  while( my $line = <OPTIONS> ) {
    chomp( $line );
    if( $line =~ m/Options for/ ) {
      $line =~ /Options for CIVET-(.*):/;
      if( $1 ne $version ) {
        die "Incompatible CIVET QC Pipeline $version for CIVET-$1.";
      }
    }
    if( $line =~ m/Cortical thickness using/ ) {
      $line =~ /Cortical thickness using (.*), blurred at (.*)/;
      push @thickness_info, ( "$1\_$2" );
    }
    if( $line =~ m/Surface area blurred/ ) {
      $line =~ /Surface area blurred at (.*)/;
      push @area_info, ( $1 );
    }
    if( $line =~ m/Surface volume blurred/ ) {
      $line =~ /Surface volume blurred at (.*)/;
      push @volume_info, ( $1 );
    }
  }

  close( OPTIONS );
  return( \@thickness_info, \@area_info, \@volume_info );
}

# QC function to validate voxel size. For good performance, the
# voxel size should be small enough.

sub check_voxel_size {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( $val > 2.5 ) {
      return( $Qc_danger );
    } else {
      if( $val > 1.5 ) {
        return( $Qc_warning );
      } else {
        return( $Qc_good );
      }
    }
  } else {
    return( $Qc_incomplete );
  }
}

# QC function to validate a metric. For good performance, the
# value should be less than two standard deviations above its mean.

sub check_stdev_above {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( $val > $mean+3*$stdev ) {
      return( $Qc_danger );
    } else {
      if( $val > $mean+2*$stdev ) {
        return( $Qc_warning );
      } else {
        return( $Qc_good );
      }
    }
  } else {
    return( $Qc_incomplete );
  }
}

# QC function to validate a metric. For good performance, the
# value should be within two standard deviations of its mean.

sub check_stdev_centered {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( abs($val-$mean) > 3*$stdev ) {
      return( $Qc_danger );
    } else {
      if( abs($val-$mean) > 2*$stdev ) {
        return( $Qc_warning );
      } else {
        return( $Qc_good );
      }
    }
  } else {
    return( $Qc_incomplete );
  }
}


# QC function to validate self and surf-surf intersections. For good 
# performance, the number of intersections on the resampled surfaces 
# should be small.

sub check_intersections {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( $val > 100 ) {
      return( $Qc_danger );
    } else {
      if( $val > 50 ) {
        return( $Qc_warning );
      } else {
        return( $Qc_good );
      }
    }
  } else {
    return( $Qc_incomplete );
  }
}

# QC function to validate gray surface expansion. For good 
# performance, the minimum value of the Laplacian field on
# the gray surface should be close to 10.

sub check_laplacian_min {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( $val < 7.5 || $val > 10.0 ) {
      return( $Qc_warning );
    } else {
      return( $Qc_good );
    }
  } else {
    return( $Qc_incomplete );
  }
}

# QC function to validate gray surface expansion. For good 
# performance, the mean value of the Laplacian field on
# the gray surface should be close to 10.

sub check_laplacian_mean {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( $val < 9.9 || $val > 10.1 ) {
      if( $val < 9.0 ) {
        return( $Qc_danger );
      } else {
        return( $Qc_warning );
      }
    } else {
      return( $Qc_good );
    }
  } else {
    return( $Qc_incomplete );
  }
}

# QC function to validate gray surface expansion. For good 
# performance, the maximum value of the Laplacian field on
# the gray surface should be close to 10.

sub check_laplacian_max {

  my $val = shift;
  my $mean = shift;
  my $stdev = shift;

  if( defined( $val ) ) {
    if( $val < 9.95 || $val > 10.5 ) {
      return( $Qc_warning );
    } else {
      return( $Qc_good );
    }
  } else {
    return( $Qc_incomplete );
  }
}


# Set interrupt handler (for cleaning of lock files)

sub CLEANUP {
  exit(1);
}


