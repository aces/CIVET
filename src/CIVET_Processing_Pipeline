#! /usr/bin/env perl

############################################################################
############################################################################
### Run CIVET processing pipeline within the PMP framework. 
###         
###   In the current version, CIVET requires a quarantine of the software
###   invoked and an environment file.
###                                       
###   Authors:                                  
###         Original pipeline scripts by: Jason Lerch 
###         Pre-modular versions of CIVET: Yasser Ad-Dab'bagh             
###         Modular CIVET: Oliver Lyttelton, J-Sebastian Muehlboeck, 
###                        Yasser Ad-Dab'bagh, Kelvin Mok, Claude Lepage
###         Project started in May 3, 2005       
###       
### For more information, have a look at our documentation at:
###    http://wiki.bic.mni.mcgill.ca/index.php/CIVET
###                                 
############################################################################
############################################################################

use strict;
use FindBin;

# All modules that will be used in either case are declared here
use Getopt::Tabular;
use PMP::PMP;
use PMP::pbs;
use PMP::sge;
use PMP::spawn;
use PMP::Array;
use MNI::Startup;
use MNI::PathUtilities qw(split_path);
use MNI::FileUtilities qw(check_output_dirs check_output_path);
use MNI::DataDir;

use lib "$FindBin::Bin";
use MRI_Image;
use Processing_Pipeline_Main;

my $version = "1.0.1";
my $versionDate= "September 12, 2006";
my $authors= "Yasser Ad-Dab'bagh, Oliver Lyttelton, J-Sebastian Muehlboeck, Kelvin Mok, and Claude Lepage";
my $usage = "\nUSAGE:\n$ProgramName -sourcedir <dir> -targetdir <dir> -prefix <prefix> [options] id1 id2 ... idn > <logfile> &\n 
ALTERNATIVE USAGE:\n
$ProgramName -sourcedir <dir> -targetdir <dir> -prefix <prefix> -id-file <idfile> [options]  > <logfile> &\n\n";

=pod
Although technically optional, you should add the following at the end of the command line:
"> logfile.txt &", as is shown in the "my $usage" line above...
this writes the pipeline output to a log file in the working directory, and allows the pipeline to
run in the background.
Also note that CIVET.pl will optionally run with a text file listing the id's as input, instead of
typing a series of 'idn' in the command line. This is especially useful when processing a large
number of id's at once, which when typed individually could lead the command line to exceed the
character number limts.
=cut

my $help = <<HELP;

$ProgramName, version $version, released $versionDate.
    Released by $authors.

    Takes any number of multi or single spectral input MINC volumes and
    extracts the cortical surfaces from them utilizing the PMP pipeline
    system. It then calculates cortical thickness at each vertex of the 
    produced cortical surfaces (non-linearly registered) using the t-link 
    metric (in both Talairach and native spaces). It can also produce ANIMAL 
    segmentations, symmetry analyses, regional thickness, surface areas 
    and volumes for brain lobes.

HELP
Getopt::Tabular::SetHelp($help, $usage);

####################
# Argument handling:
####################

my $reset = undef;
my $command = "printStatus";
my $PMPtype = "sge";
my $pbsQueue = "long";
my $pbsHosts = "yorick:bullcalf";
my $sgeQueue = "aces.q";
my $resetRunning = 1;

############# User defined registration target models 
############# (defaults defined below in the 'registration targets' section)
my $TemplateSize = "1.00";
my $regModelDir = undef;
my $regModel = undef;
my $groupModel = undef;
my $groupModelDir = undef;
my $smallSurfRegModelDir = undef;
my $smallSurfRegModel = undef;
my $smallSurfModelDataTerm = undef;
my $largeSurfRegModelDir = undef;
my $largeSurfRegModel = undef;
my $largeSurfModelDataTerm = undef;

############# Use model specific pre-registration
my $groupReg = 0;

############# The status report filename:
my $statusReportFile = "CIVET_status_report.csv";

############# Options for how CIVET is to be run: the default will be to run
############# t1 data, cleaning tags, ANIMAL, the production of 82k 
############# polygon surfaces, no symmetry stages, and surface registration. 
############# Default volumetric blurring is at 10mmFWHM. 
my $inputType = "t1only";
my $maskType = "t1only";
my $cropNeck = undef;
my $N3Distance = 200;
my $VBM = "VBM";
my $animal = "ANIMAL";
my $surface = "SURFACE";
my @thickness = (undef,undef);

############# Some directories that the user will need to specify
my $sourceDir = undef;
my $target = undef;
my $prefix = undef;
my $sourceSubDir = "noIdSubDir";
my $idTextFile = undef;


############# Options table
my @leftOverArgs;
my @argTbl = (
          ["Execution control", "section"],
          ["-spawn", "const", "spawn", \$PMPtype, "Use the perl system interface to spawn jobs"],
          ["-sge", "const", "sge", \$PMPtype, "Use SGE to spawn jobs."],
          ["-pbs", "const", "pbs", \$PMPtype, "Use PBS to spawn jobs"],

          ["PBS options", "section"],
          ["-pbs-queue", "string", 1, \$pbsQueue, "Which PBS queue to use [short|medium|long]"],
          ["-pbs-hosts", "string", 1, \$pbsHosts, "Colon separated list of pbs hosts"],

          ["SGE options", "section"],
          ["-sge-queue", "string", 1, \$sgeQueue, "Which SGE queue to use"],

          ["File options", "section"],
          ["-sourcedir", "string", 1, \$sourceDir, "Directory containing the source files."],
          ["-targetdir", "string", 1, \$target, "Directory where processed data will be placed."],
          ["-prefix", "string", 1, \$prefix, "File prefix to be used in naming output files."],
          ["-id-subdir", "const", "IdSubDir", \$sourceSubDir, "Indicate that the source directory contains sub-directories for each id"],
          ["-id-file", "string", 1, \$idTextFile, "A text file that contains all the subject id's (separated by space, tab, return or comma) that CIVET will run on."],

          ["Pipeline options", "section"],
          ["-template", "string", 1, \$TemplateSize, 
           "Define the template for image processing (0.50, 0.75, 1.00, 1.50, 2.00, 3.00, 4.00, 6.00)."],
          ["-registration-model", "string", 1, \$regModel, "Define the target model for registration."],
          ["-registration-modeldir", "string", 1, \$regModelDir, "Define the directory of the target model for registration."],

#          ["-82k-surface-model", "string", 1, \$smallSurfRegModel, "Define the surface registration model."],
#          ["-82k-surface-modeldir", "string", 1, \$smallSurfRegModelDir, "Define the directory for the surface registration model."],
#          ["-328k-surface-model", "string", 1, \$largeSurfRegModel, "Define the surface registration model."],
#          ["-328k-surface-modeldir", "string", 1, \$largeSurfRegModelDir, "Define the directory for the surface registration model."],
#          ["-328k-surface-data-term", "string", 1, \$largeSurfModelDataTerm, "Define the data-term file for surface registration."],

#          ["-group-specific-registration|-normal-registration", "boolean", undef, \$groupReg, "Add a ( pediatric) intermediate model registration."],
#          ["-group-specific-model", "string", 1, \$groupModel, "Define the intermediate registration target for (default pediatric) data."],
#          ["-group-specific-modeldir", "string", 1, \$groupModelDir, "Define the directory of the intermediate registration target for (default pediatric) data."],

          ["CIVET options", "section"],  
          ["-multispectral", "const", "multispectral", \$inputType, 
           "Use T1, T2 and PD native files for tissue classification."],
          ["-spectral_mask", "const", "multispectral", \$maskType, 
           "Use T1, T2 and PD native files for brain masking."],
          ["-crop-neck", "string", 1, \$cropNeck, 
           "Percentage of height to crop to remove neck for masking."],
          ["-N3-distance", "string", 1, \$N3Distance, 
           "N3 spline distance in mm (suggested values: 200 for 1.5T scan (default); 25 for 3T scan)."],
          ["-no-surfaces", "const", "noSURFACE", \$surface, "don't build surfaces"],
          ["-no-animal", "const", "noANIMAL", \$animal, "don't run volumetric ANIMAL segmentation."],
          ["-thickness", "string", 2, \@thickness,
           "compute cortical thickness and blur [tlink|tlaplace|tnear|tnormal] [kernel size in mm]"],

          ["Pipeline control", "section"],
          ["-run", "const", "run", \$command, "Run the pipeline."],
          ["-status-from-files", "const", "statusFromFiles", \$command, "Compute pipeline status from files"],
          ["-print-stages", "const", "printStages", \$command, "Print the pipeline stages."],
          ["-print-status", "const", "printStatus", \$command, "Print the status of each pipeline."],
          ["-make-graph", "const", "makeGraph", \$command, "Create dot graph file."],
          ["-make-filename-graph", "const", "makeFilenameGraph", \$command, "Create dot graph of filenames."],
          ["-print-status-report", "const", "printStatusReport", \$command, "Writes a CSV status report to file in cwd."],

          ["Stage Control", "section"],
          ["-reset-all", "const", "resetAll", \$reset, "Start the pipeline from the beginning."],
          ["-reset-from", "string", 1, \$reset, "Restart from the specified stage."],
          ["-reset-running|-no-reset-running", "boolean", 1, \$resetRunning, "Restart currently running jobs."],
          );

GetOptions(\@argTbl, \@ARGV, \@leftOverArgs) or die "\n";

############# Basic usage
my @dsids;

if ($idTextFile) {
    open (IDTEXTFILE, "$idTextFile") or die ("Cannot open '$idTextFile': $!");
    # read the whole text file into one string
    my $idstext = "";
    while (my $idline = <IDTEXTFILE>) {
    $idstext .= $idline;
    }
    close (IDTEXTFILE) or die ("Cannot close '$idTextFile': $!");
    # split the string on whitespace (\s) or comma
    @dsids = split(/[\s,]+/, $idstext);
} 
else {
    @dsids = @leftOverArgs or die $usage;
}

unless ($prefix && $target && $sourceDir) {
    die "\n\n*******ERROR********: \n     You must specify -prefix, -targetdir, and -sourcedir \n********************\n\n\n";
}

############# Set no file buffering for stdout (buffer is printed every 1 line)
$| = 1;

############# Print the CIVET options list and related error messages
my $DATE = `date`;
chomp( $DATE );
my $UNAME = `uname -s -n -r`;
chomp( $UNAME );
print "\n\n* Pipeline started at $DATE on $UNAME \n";
print "\n* CIVET Command line is:\n       $0 @ARGV \n";
print "\n* The source directory is: '$sourceDir' \n";
print "* The target directory is: '$target' \n";
print "* The prefix is: '$prefix' \n";
print "* The PMP class is: '$PMPtype' \n";
if ($PMPtype eq "pbs") {
    print "* The pbs queue type is: '$pbsQueue' \n";
    print "* The pbs batch host(s) is/are: '$pbsHosts' \n";
}
if ($PMPtype eq "sge") {
    print "* The sge queue type is: '$sgeQueue' \n";
}


############# Some essential directories 
my $ICBM_dir = MNI::DataDir::dir("ICBM");
my $classify_dir = MNI::DataDir::dir("classify");


############# The -like template (0.50, 0.75, 1.00, 1.50, 2.00, 3.00, 4.00, 6.00)
my $Template = "${ICBM_dir}/icbm_template_${TemplateSize}mm.mnc";


############# Define registration targets and directories and print them
unless ($regModelDir) {
    $regModelDir = MNI::DataDir::dir("mni_autoreg");
}
print "* Registration model directory is:\n  $regModelDir \n";

unless ($regModel) {
    $regModel = "icbm_avg_152_t1_tal_nlin_symmetric_VI";
}
print "* Registration model is:\n   $regModel \n";


############# Define intermediate registration targets and directories and print them
 my $intermediate_model = undef;
 if ($groupReg){
     my $tempy =  MNI::DataDir::dir("mni_autoreg");
     $intermediate_model = "${tempy}/nih_chp_avg";
     print "* Group registration model directory is:\n $groupModelDir \n";
}


############# Define Surface registration targets and directories and print them, or die with error message
#fixme this is going to change with the hemisphere aproach
=pod
unless ($smallSurfRegModelDir) {
    $smallSurfRegModelDir = MNI::DataDir::dir("surfreg");
}
unless ($smallSurfRegModel) {
    $smallSurfRegModel = "${smallSurfRegModelDir}/mni_icbm_00244_white_surface_81920.obj";
}

unless ($smallSurfModelDataTerm) {
    $smallSurfModelDataTerm = "${smallSurfRegModelDir}/mni_icbm_00244_white_surface_81920_data_term1.vv";
}
unless ($largeSurfRegModelDir) {
    $largeSurfRegModelDir = MNI::DataDir::dir("surfreg");
}
=cut


############# Print the Pipeline and Stage Control commands

if( !($command eq "run") ) {
	$resetRunning = 0;
}
print "\n\n* Pipeline Control command is: '$command'";
	
if ($reset and $resetRunning ne 0){
    print "\n* Stage control commands are: '$reset' and 'reset-running'";
}
elsif ($reset and $resetRunning eq 0){
    print "\n* Stage control commands are: '$reset' and 'no-reset-running'";
}

print "\n\n\n* Data-set Subject ID(s) is/are: '@dsids'\n\n\n";

my $second_model_dir = "$FindBin::Bin/models";
my $fullpath_regmodel = "${regModelDir}/${regModel}";

system("mkdir -p ${target}") if (! -d ${target});


############# An array to store the pipeline definitions for each subject
my $pipes = PMP::Array->new();

#########################################################
# Set up the pipeline output directories for each subject
#########################################################
foreach my $dsid (@dsids) {

    ##### Create image object. #####

    # depending on the two options your files can be in on target
    # or there can be subdirs for every subject
    my $Source_Base;
    if ($sourceSubDir eq "noIdSubDir") {
      $Source_Base = "${sourceDir}/";
    } else {
      $Source_Base = "${sourceDir}/${dsid}/";
    }

    my $image = MRI_Image->new( $Source_Base,
                                $target,
                                $prefix,
                                $dsid,
                                $inputType,
                                $maskType,
                                $cropNeck,
                                $N3Distance,
                                $surface,
                                $animal,
                                \@thickness );

    ##### Create the pipeline environment. #####

    my $pipeline;
    
    if ($PMPtype eq "spawn") {
        $pipeline = PMP::spawn->new();
    } elsif ($PMPtype eq "sge") {
        $pipeline = PMP::sge->new();
        $pipeline->setQueue($sgeQueue);
	$pipeline->setPriorityScheme("later-stages");
    } elsif ($PMPtype eq "pbs") {
        $pipeline = PMP::pbs->new();
        $pipeline->setQueue($pbsQueue);
        $pipeline->setPriorityScheme("later-stages");
    }

    # set some generic pipeline options
    $pipeline->name($dsid);
    $pipeline->debug(0);
    $pipeline->statusDir("${target}/${dsid}/logs");
    
##################################### ################# #################
# This used to be the definition of stages... Now it is in modules       
##################################### ################# #################

    CIVET_Main::create_pipeline(
                        \$pipeline,
                        \$image,
                        $fullpath_regmodel,
                        $intermediate_model, 
                        $smallSurfRegModel,
                        $Template,
                        $second_model_dir
                        );    

####################################################################################
# Pipeline management
####################################################################################

############# Rerun any failures from a previous run of this subjects pipe
    $pipeline->resetFailures();

############# Reset running jobs if that's what the user wants.
    
    if ($resetRunning) {
      $pipeline->resetRunning();
    }
   
############# Restart all stages; restart from a given stage;
############# or continue from current status.

   $pipeline->updateStatus();
   if ($reset) {
      if ($reset eq "resetAll") {
        $pipeline->resetAll();
      } else {
        $pipeline->resetFromStage($reset);
      }
   }
 
############# Add this pipe to our happy array of pipes
    
    $pipes->addPipe($pipeline);
    
} ####################################### end of foreach


############# Now run whatever it is that the user wanted done

if ($command eq "printStatus" ) {
    $pipes->printUnfinished();
}

elsif ($command eq "printStatusReport") {
    $pipes->printStatusReport($statusReportFile);
}

elsif ($command eq "statusFromFiles") {
    $pipes->updateFromFiles();
    $pipes->printUnfinished();
}

elsif ($command eq "printStages") {
    $pipes->printStages();
}

elsif ($command eq "makeGraph") {
    $pipes->createDotGraph("dependency-graph.dot");
}

elsif ($command eq "makeFilenameGraph") {
    $pipes->createFilenameDotGraph("filename-dependency-graph.dot","${target}/$dsids[0]/");
}

elsif ($command eq "run") { 
    # register all the programs
    $pipes->registerPrograms();
    $pipes->run();
}

else {
    print "huh? Grunkle little gnu, grunkle\n";
}

############# Voila!! #############
