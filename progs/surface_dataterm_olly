#! /usr/bin/env perl
#
# Surface Feature Extractor
#
# Oliver Lyttelton oliver@bic.mni.mcgill.ca

#

use strict;
use warnings "all";
use Getopt::Tabular;
use File::Basename;
use File::Temp qw/ tempdir /;


my($Help, $Usage, $me);
my(@opt_table, $source, $target, $outxfm, @args, $tmpdir);

$me = &basename($0);

my $feature_choice = 0;
my $measurement_choice = 0;
my $extraction_transform = undef;
my $blurfwhm = undef;
my $alignment_transform = undef;
my $model_mid_surface = undef;
my $verbose = 0;
my $clobber = 0;
my $template_paint = undef;
my $template_labels = undef;
my $flip_transform = undef;
my $volume_feature = undef;
my $volume_feature_intersect = undef;

   
$Help = <<HELP;
|    $me extracts a surface dataterm to be used in surface registration
| 
| Problems or comments should be sent to: oliver\@bic.mni.mcgill.ca
HELP

$Usage = "Usage: $me input.obj output.txt\n".
         "       $me -help to list options\n\n";

@opt_table = (
         
        ["-verbose","const","1", \$verbose,
        "be verbose" ]
   );

# Check arguments
&Getopt::Tabular::SetHelp($Help, $Usage);
&GetOptions (\@opt_table, \@ARGV) || exit 1;
die $Usage if($#ARGV != 1);
my $obj= shift(@ARGV);
my $output= shift(@ARGV);

# make tmpdir
$tmpdir = &tempdir( "$me-XXXXXXXX", TMPDIR => 1, CLEANUP => 1 );


                
#set up internal variables

my $mean_curvature = "${tmpdir}/mean_curvature.txt";
my $blur5 = "${tmpdir}/blur5.txt";
my $blur10 = "${tmpdir}/blur10.txt";
my $blur20 = "${tmpdir}/blur20.txt";



&do_cmd("surface-curvature" ,"-mean",$mean_curvature,$obj);

&do_cmd("diffuse","-parametric","0","-kernel","5",$obj,$mean_curvature,$blur5);
&do_cmd("diffuse","-parametric","0","-kernel","10",$obj,$mean_curvature,$blur10);
&do_cmd("diffuse","-parametric","0","-kernel","20",$obj,$mean_curvature,$blur20);

open INCURV,$mean_curvature;
open INCURVB5,$blur5;
open INCURVB10,$blur10;
open INCURVB20,$blur20;

open(OUT,">${output}");

my $num_vert;
my @curv = <INCURV>;
my @curvb5 = <INCURVB5>;
my @curvb10 = <INCURVB10>;
my @curvb20 = <INCURVB20>;

my $counter = 0;
my $line;
my $header;
my $i;
  for ($i=0;$i<=$#curv;$i++){
     my $answ =  $curv[$i] + 2*$curvb5[$i] + 4*$curvb10[$i] + 8*$curvb20[$i];
    print OUT "${answ}\n";
  }
 close(INCURV);
 close(INCURVB5);
 close(INCURVB10);
 close(INCURVB20);  
 close(OUT);
 

sub do_cmd { 
   print STDOUT "@_\n" if ($verbose);
   system(@_) == 0 or die;
}












