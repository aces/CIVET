#!/usr/bin/env perl

# Using N3, these stages will run an initial correction of intensity
# non-uniformity on the native or linearly registered images. 
#
# Here is how nu_correct works:
#   - a brain mask should always be given to nu_correct, as nu_correct
#     needs one
#   - if no brain mask is given, nu_correct will build one (-auto_mask)
#     * the image is in Talairach space, in this case use avg305 mask
#     * the image is not in Talairach space, in this case use biModalT
#       to get some kind of mask, but this mask usually includes some
#       of the skull and neck tissues (and does not produce great results)
#     * neither avg305_mask or biModalT mask is good -- we must provide an
#       explicit mask
#   - to generate an initial brain mask in native space, crop the neck,
#     do a quick linear registration to the model (-nmi) then use the
#     model's mask (inverted linear xfm).
#   - the icbm152 mask is provided in stx space (better and avg305)
# 
# Be careful: the input file might come as .mnc.gz.
#
# In the arguments, $nuc_dist is the distance between knots in the b-spline.
# The accuracy of nu_correct is quite sensitive to this distance. A small
# value is more accurate, but it must not be chosen too small so as not to
# remove biological variations. The smaller d is, the longer the code will
# take to run. Accuracy is not free. For 1.5T scans, d=200 is used but this
# can created hot spots in the corrected 3T images when the spline is not able 
# to represent non-uniformities at a smaller wavelength. (This likely depends
# on the scanner too.) For 3T scans, d=50 to 100 seems to give reliable
# results. 
#
# Copyright Alan C. Evans
# Professor of Neurology
# McGill University
#

use strict;
use warnings "all";
use File::Basename;
use File::Temp qw/ tempdir /;

# Directory for temporary files.
my $me = &basename($0);
my $tmpdir = &tempdir( "$me-XXXXXX", TMPDIR => 1, CLEANUP => 1 );

my $input = $ARGV[0];         # input image t1, t2, or pd
my $output = $ARGV[1];        # output of N3 on input image
my $space = $ARGV[2];         # space = "native" or "stx"
my $model = $ARGV[3];         # path+basename of model for the population average
my $mask = $ARGV[4];          # actual brain mask of the subject (or "none")
my $headheight = $ARGV[5];    # distance from top of head for neck-cropping
my $nuc_dist = $ARGV[6];
my $nuc_damping = $ARGV[7];   # for future usage
my $nuc_cycles = $ARGV[8];
my $nuc_iters = $ARGV[9];

# apply non-uniformity correction and intensity normalization on image.

if ( -e $input ) {

  my $tmp = "${tmpdir}/nuc.mnc";

  my $tmp_input = $input;

  # In native space, do neck-cropping to help linear registration.

  if( $space eq "native" and $headheight > 0 ) {
    $tmp_input = "${tmpdir}/t1_cropped.mnc";
    &cropneck( $input, $headheight, $tmp_input );
  }

  # Use a mask if one is given. Resample the mask to be like the input.
  # This can happen if a model's mask is used which does not match the
  # template used to resample the input. If no mask is given, try a 
  # full head linear registration and use the mask from the template
  # as a starting point.

  my $initial_mask = undef;
  if( $space eq "native" ) {
    $initial_mask = "${tmpdir}/nuc_mask.mnc";
    if( ( $mask ne "none" ) and ( -e $mask ) ) {
      # user-supplied mask, simply resample it like image
      &run( "mincresample", "-like", $tmp_input, "-nearest_neighbour",
            $mask, $initial_mask );
    } else {
      # no mask: create one from the population model
      &run( 'bestlinreg.pl', '-clobber', '-lsq12', '-nmi', $tmp_input, 
            "${model}.mnc", "${tmpdir}/native2tal.xfm" );
      &run( 'mincresample', '-clobber', '-quiet', '-like', $tmp_input, 
            '-nearest', '-transform', "${tmpdir}/native2tal.xfm", '-invert', 
            "${model}\_mask.mnc", $initial_mask );
      unlink( "${tmpdir}/native2tal.xfm" );
      &run( 'mincdefrag', $initial_mask, $initial_mask, 1, 6 );
      &run( 'dilate_volume', $initial_mask, $initial_mask, 1, 6, 1 );
    }
  } else {
    # model's mask in stereotaxic space (assumes good registration).
    # At this point, we don't have the non-linear transformation.
    $initial_mask = "${model}\_mask.mnc";
  }

  # Important note: Because of the way nu_correct converges, it is better to
  # do a few sets of 100 iterations rather than a total number of iterations
  # at once. For example, nu_correct often thinks it has converged after 50-60
  # iterations, so repeating the cycle will provide more iterations. Please
  # leave as it is until nu_correct is fixed.

  for( my $i = 0; $i < $nuc_cycles; $i++ ) {
    &run( "nu_correct", "-clobber", "-iter", $nuc_iters, "-stop", 0.00001,
          "-fwhm", 0.1, "-distance", $nuc_dist, '-mask', $initial_mask,
          $tmp_input, $output );
    &run( "mv", "-f", $output, $tmp );
    $tmp_input = $tmp;
    # Clear minc history to avoid a bug in netCDF-3.6.1 (see Claude)
    &run( "minc_modify_header", "-sinsert", ":history=\"\"", $tmp );
  }

  # We remove the .imp file as it is relative to the previous
  # cycle, thus meaningless globally.

  my $imp_file = $output;
  $imp_file =~ s/\.[^\.]*$/\.imp/;
  &run( "rm", "-f", $imp_file );

  # remove high extremum (low extremum - background - will be taken care of by the mask).
  my $top;
  my $upper = 99.950;
  chomp($top = `mincstats -quiet -pctT $upper $tmp`);

  my $clip_expr = "if(A[0]<0){out=0;}else{if(A[0]>${top}){out=${top};}else{out=A[0];}}";

  &run( "minccalc", "-clobber", "-expression", $clip_expr, $tmp, $output );
  # This is ugly! Clear minc history to avoid a bug in netCDF-3.6.1 (see Claude)
  &run( "minc_modify_header", "-sinsert", ":history=\"\"", $output );

}

# Determine how to crop the neck in native space, up to a given
# distance from the top of the skull. Assume axial direction in
# the z-direction.

sub cropneck {

  my $input = shift;
  my $headheight = shift;
  my $output = shift;

  my $nz = `mincinfo -dimlength zspace $input`; chomp( $nz );
  my $dz = `mincinfo -attvalue zspace:step $input`; chomp( $dz );
  my $zstart = `mincinfo -attvalue zspace:start $input`; chomp( $zstart );
  # work in positive z-direction
  if( $dz < 0 ) {
    $zstart += ( $nz - 1 ) * $dz;
    $dz = -$dz;
  }
  my $sz = $zstart;

  my @avg = ();
  my $maxavg = 0;
  my $minavg = undef;
  my @stdev = ();
  my $maxstdev = 0;
  my $minstdev = undef;

  for( my $j = 1; $j < $nz; $j+=2 ) {
    `mincresample -clobber -quiet -znelements 1 -zstart $sz $input ${tmpdir}/slice.mnc`;
    my $ret = `mincstats -quiet -mean ${tmpdir}/slice.mnc`; chomp( $ret );
    push @avg, $ret;
    $maxavg = $ret if( $ret > $maxavg );
    $minavg = $ret if( !defined( $minavg ) );
    $minavg = $ret if( $ret < $minavg );
    my $ret2 = `mincstats -quiet -stddev ${tmpdir}/slice.mnc`; chomp( $ret2 );
    push @stdev, $ret2;
    $maxstdev = $ret2 if( $ret2 > $maxstdev );
    $minstdev = $ret2 if( !defined( $minstdev ) );
    $minstdev = $ret2 if( $ret2 < $minstdev );
    $sz += 2*$dz;
  }
  unlink( "${tmpdir}/slice.mnc" );

  $maxavg = $minavg + 0.15 * ( $maxavg - $minavg );
  $maxstdev = $minstdev + 0.10 * ( $maxstdev - $minstdev );
  for( my $j = 1; $j < $nz; $j+=2 ) {
    $sz -= 2*$dz;
    my $ret = pop @avg;
    my $ret2 = pop @stdev;
    last if( $ret > $maxavg || $ret2 > $maxstdev );
  }
  $sz -= $headheight;
  my $wcrop = $sz - $zstart;   # this is the world coord at bottom of cerebellum

  if( $wcrop > 0 ) {
    &run( 'autocrop', '-clobber', '-extend', '0,0', '0,0', "-$wcrop,0",
          $input, $output );
  } else {
    &run( 'cp', '-f', $input, $output );
  }
}

# Execute a system call.

sub run {
  print "@_\n";
  system(@_)==0 or die "Command @_ failed with status: $?";
}

