#! /usr/bin/env perl
#
# Surface Feature Extractor
#
# Authors:
#   Oliver Lyttelton oliver@bic.mni.mcgill.ca
#
# Copyright Alan C. Evans
# Professor of Neurology
# McGill University
#

use strict ;
use warnings "all" ;
use Getopt::Tabular ;
use File::Basename ;
use File::Temp qw/ tempdir / ;
# use Math::BigFloat;
use MNI::MiscUtilities qw(shellquote);

# inputs:
my $cls_correct = shift;
my $pve_wm = shift;
my $pve_csf = shift;
my $final_callosum = shift;
my $final_classify = shift;
my $skel_csf = shift;
my $nl_transform = shift;
my $Second_model_Dir = shift;

# make tmpdir:
my $me = &basename($0);
my $tmpdir = &tempdir( "$me-XXXXXXXX", TMPDIR => 1, CLEANUP => 1 ) ;

# temporary outputs:
my $custom_mask = "${tmpdir}/custom_mask.mnc";
my $classified_wm_fixed = "${tmpdir}/classified_wm_fixed.mnc";
my $classified_wm_gm_fixed = "${tmpdir}/classified_wm_gm_fixed.mnc";

# disable internal compression on temporary files (much faster)

my $MINC_COMPRESS = $ENV{'MINC_COMPRESS'};
$ENV{'MINC_COMPRESS'} = 0;

# create $custom_mask

make_custom_mask( $cls_correct, $nl_transform, $custom_mask, $Second_model_Dir );

plug_ventricles( $cls_correct, $custom_mask );

# copy contiguous pieces of white matter from pve image and custom mask

fix_wm( $cls_correct, $pve_wm, $custom_mask, $classified_wm_fixed );
unlink( $custom_mask );

# fix gray matter voxels

fix_gm( $classified_wm_fixed, $classified_wm_gm_fixed );
unlink( $classified_wm_fixed );

# enable internal compression on output files

$ENV{'MINC_COMPRESS'} = $MINC_COMPRESS if( defined $MINC_COMPRESS );

# change WM voxels in contact with CSF/BG to GM.

run( "minccalc", "-quiet", "-clobber", "-byte", "-unsigned", 
     "-expression", "if(abs(A[0])<0.5||abs(A[0]-1)<0.5){1}else{0}",
     $classified_wm_gm_fixed, "${tmpdir}/csf_bg_mask.mnc" );
run( "dilate_volume", "${tmpdir}/csf_bg_mask.mnc", 
     "${tmpdir}/csf_bg_mask.mnc", 1, 6, 1, $classified_wm_gm_fixed, 2.5, 3.5 );
run( "minccalc", "-quiet", "-clobber",
     "-expression", "if(abs(A[0]-3)<0.5&&abs(A[1]-1)<0.5){2}else{A[0]}",
     $classified_wm_gm_fixed, "${tmpdir}/csf_bg_mask.mnc", "${tmpdir}/new_cls.mnc" );
run( "mv", "-f", "${tmpdir}/new_cls.mnc", $classified_wm_gm_fixed );
unlink( "${tmpdir}/csf_bg_mask.mnc" );

# create a midline mask to separate the hemispheres

create_midline_mask( $classified_wm_gm_fixed, $final_callosum );

# final classification

run( "minccalc", "-clobber", "-expr", 
     "if(A[1]>0){out=A[1];}else{out=A[0];}",
     $classified_wm_gm_fixed, $final_callosum, $final_classify );
unlink( $classified_wm_gm_fixed );

# create the csf skeleton

make_csf_skel( $final_classify, $pve_csf, $skel_csf, $tmpdir );

# the end!


# create the csf skeleton

sub make_csf_skel {

  my $cls_correct = shift;
  my $pve_csf = shift;
  my $skel_csf = shift;
  my $tmpdir = shift;

  my $wm_gm_mask = "${tmpdir}/wm_gm_mask.mnc";
  my $wm_gm_maskD = "${tmpdir}/wm_gm_mask_dil.mnc";
  my $pve_csf_dil = "${tmpdir}/pve_csf_dil.mnc";

  # Make sure there is a layer of CSF around the cortex:
  #   - select white + gray
  #   - dilate white + gray by one voxel layer
  #   - add csf to the skeleton in the dilated layer of the mask
  #   - create the fixed skeleton to be used in the Laplacian
  #     field for the gray surface extraction.
  # NOTE: If you don't do this step, the skeleton will go through
  #       the gray matter if there is no layer of csf between gray
  #       and background. This will truncate the gray matter and
  #       make the cortex thinner.

  run( "minccalc", "-clobber", "-byte", "-expression",
       "if(A[0]>1.5){out=1;}else{out=0;}", $cls_correct, $wm_gm_mask );
  run( "dilate_volume", $wm_gm_mask, $wm_gm_maskD, "1", "26", "1" );
  unlink( $wm_gm_mask );
  run( "minccalc", "-clobber", "-byte", "-expression", 
       "if((A[1]<1.5&&A[2]>0.5)||A[0]>1.0e-06){out=1;}else{out=0;}",
       $pve_csf, $cls_correct, $wm_gm_maskD, $pve_csf_dil );
  unlink( $wm_gm_maskD );
  run( "skel", $pve_csf_dil, $skel_csf );
  unlink( $pve_csf_dil );
}


# create custom_mask to mask sub-cortical gray and fill up ventricles.

sub make_custom_mask {

  my $cls_correct = shift;
  my $nl_transform = shift;
  my $custom_mask = shift;
  my $Second_model_Dir = shift;
 
  my $model_mask = "${Second_model_Dir}/Cerebellum_Ventricles_SubCortical_Mask.mnc";
  run( "mincresample", "-clobber", "-like", $cls_correct, 
       "-invert_transformation", "-nearest_neighbour",
       "-transform", $nl_transform, $model_mask, $custom_mask );
}


# fix_wm is a little bit of image processing alchemy that attempts 
# the following:
#   1) adds the wm skeleton to the wm image by removing any loose ends 
#      by blurring and cropping 
#   2) blurs and crops the whole image, and its negative iteratively, 
#      to remove "nonsense" voxels
# Problems or comments should be sent to: oliver\@bic.mni.mcgill.ca
#
# fix_wm( classified.mnc, pve_wm, custom_mask.mnc, output.mnc )
#

sub fix_wm {

  my $classified =  shift;
  my $pve_wm =  shift;
  my $custom_mask = shift;
  my $output = shift;

  my $classified_temp= "${tmpdir}/classified_plugged.mnc" ;
  my $pve_wm_temp = "${tmpdir}/pve_plugged.mnc" ;
  my $pve_wm_skel = "${tmpdir}/temp_skel.mnc" ;
  my $temp_blur = "${tmpdir}/temp_blur" ;
  my $pve_wm_skel_new = "${tmpdir}/temp_skel_new.mnc" ;
  my $temp_diff = "${tmpdir}/temp_diff.mnc" ;
  my $wm_with_skel = "${tmpdir}/wm_with_skel.mnc" ;
  my $wm_with_skel_new = "${tmpdir}/wm_with_skel_new.mnc" ;
  my $iteration = 0 ;
  my $done = 0 ;
  my $integrity = 0.3 ;
  my @args = undef ;
 
  # Combine custom mask for ventricles and sub-cortical gray into white.

  run( "minccalc", "-byte", "-clobber", "-expr", 
       "if(abs(A[1]-1)<0.45||abs(A[1]-3)<0.45){out=1;}else{if(abs(A[1]-2)<0.45){out=0;}else{if(A[0]>1.0e-06){out=1;}else{out=0;}}}", 
       $pve_wm, $custom_mask, $pve_wm_temp );
   
  run( "skel", $pve_wm_temp, $pve_wm_skel );
  unlink( $pve_wm_temp );

  run( "minccalc", "-clobber", "-expr", 
       "if(abs(A[1]-1)<0.45||abs(A[1]-3)<0.45){out=3;}else{if(abs(A[1]-2)<0.45){out=1;}else{out=A[0];}}", 
       $classified, $custom_mask, $classified_temp) ;
 
  ### First Pass, add the connected skeleton voxels to the image...

  while( !$done && $iteration < 20 ) {
  
    $temp_blur = "${tmpdir}/temp_blur.mnc" ;
  
    run( "mincblur", "-clobber", "-fwhm", "2", $pve_wm_skel, $temp_blur );
 
    $temp_blur = "${temp_blur}_blur.mnc" ;
 
    run( "minccalc", "-clobber", "-expr", 
         "out=(A[0]>${integrity}||A[2]==3)&&A[1];", 
         $temp_blur, $pve_wm_skel, $classified_temp, $pve_wm_skel_new );
    unlink( $temp_blur );
 
    run( "minccalc", "-clobber", "-expr", "out=abs(A[0]-A[1]);", 
         $pve_wm_skel, $pve_wm_skel_new, $temp_diff);

    @args = ( "mincstats", "-sum", $temp_diff );
    print "@args\n" ;
    my $result = `@args` ;
    unlink( $temp_diff );
    my @line = split/\s+/, $result ;
    print ("Iteration:${iteration} Voxels changed:${line[1]}\n");
 
    $iteration = $iteration+1 ;

    if ($line[1]==0) { $done = 1 ; }
    run( "mv", "-f", $pve_wm_skel_new, $pve_wm_skel );
  }
 
  $done = 0 ;
 
  # now we have pruned the wm pve skeleton, we are going to add it to
  # the classified white matter and then get rid of nonsense voxels....

  run( "minccalc", "-clobber", "-expr", "out=A[0]||(abs(A[1]-3)<0.45);", 
       $pve_wm_skel, $classified_temp, $wm_with_skel) ;
  unlink( $pve_wm_skel );

  $iteration = 0 ;

  while( !$done && $iteration < 40 ) {
 
    $temp_blur = "${tmpdir}/temp_blur.mnc" ;
    
    run( "mincblur", "-clobber", "-fwhm", "2", $wm_with_skel, $temp_blur );
 
    $temp_blur = "${temp_blur}_blur.mnc" ;

    run( "minccalc", "-clobber", "-expr", 
         "out=if(A[0]<${integrity}&&A[1]>0.5){out==0;}else{if(A[0]>(1-${integrity})&&A[1]<0.5){out==1;}else{out=A[1];}};", 
         $temp_blur, $wm_with_skel, $wm_with_skel_new );
    unlink( $temp_blur );
 
    run( "minccalc", "-clobber", "-expr", "out=abs(A[0]-A[1]);",
         $wm_with_skel, $wm_with_skel_new, $temp_diff );

    @args = ("mincstats", "-sum", $temp_diff );
    print "@args\n" ;
    my $result = `@args`;
    unlink( $temp_diff );
    my @line = split/\s+/, $result;
    print ("Iteration B:${iteration} Voxels changed:${line[1]}\n") ;

    run( "mv", "-f", $wm_with_skel_new, $wm_with_skel );

    if( $line[1]==0 ) { $done = 1 ; }

    $iteration = $iteration+1;
  }

  # first defrag the gray and add the excluded voxels to csf unless 
  # they are surrounded by white

  run( "mincdefrag", $wm_with_skel, $wm_with_skel_new, "1", "27", "100000");

  run( "minccalc", "-clobber", "-expr", "out=A[0]<0.5;", 
       $wm_with_skel_new, $wm_with_skel );

  run( "mincdefrag", $wm_with_skel, $wm_with_skel_new, "1", "27", "100000");

  run( "minccalc", "-clobber", "-expr", "out=A[0]<0.5;", 
       $wm_with_skel_new, $wm_with_skel );
  unlink( $wm_with_skel_new );
 
  run( "minccalc", "-clobber", "-expr", 
       "if(abs(A[0]-1)>0.45&&abs(A[1]-3)<0.45){out=2;}else{if(abs(A[0]-1)<0.45&&abs(A[1]-3)>0.45){out=3}else{out=A[1];}};", 
       $wm_with_skel, $classified_temp , $output );

  unlink( $wm_with_skel );
  unlink( $classified_temp );

}


# fix_gm is a little bit of image processing alchemy that attempts 
# the following:
#   1) adds the wm skeleton to the wm image by removing any loose ends 
#      by blurring and cropping 
#   2) blurs and crops the whole image, and its negative iteratively, 
#      to remove "nonsense" voxels
# Problems or comments should be sent to: oliver\@bic.mni.mcgill.ca
#
# fix_gm( classified.mnc, output.mnc )
#

sub fix_gm {

  my $classified = shift;
  my $result = shift;

  my $temp_white = "${tmpdir}/temp_white.mnc" ;
  my $temp_white_blur_prefix = "${tmpdir}/temp_white" ;
  my $temp_white_blur = "${temp_white_blur_prefix}_blur.mnc" ;

  my $temp_gray = "${tmpdir}/temp_gray.mnc" ;
  my $temp_gray_defrag = "${tmpdir}/temp_gray_defrag.mnc" ;
  my $temp_gray_blur_prefix = "${tmpdir}/temp_gray_defrag" ;
  my $temp_gray_blur = "${temp_gray_blur_prefix}_blur.mnc" ;
  my $temp_gray_new = "${tmpdir}/temp_gray_defrag_new.mnc" ;
  my $temp_gray_diff = "${tmpdir}/temp_gray_diff.mnc" ;
  my $done = 0 ;
  my $count =0 ;
  my @args = undef ;
  
  run( "minccalc", "-clobber", "-expr", 'out=abs(A[0]-3)<0.45;', 
       $classified, $temp_white );
  run( "mincblur", "-clobber", "-fwhm", "2", $temp_white, 
       $temp_white_blur_prefix );
  unlink( $temp_white );
  run( "minccalc", "-clobber", "-expr", 'out=abs(A[0]-2)<0.45;', 
       $classified, $temp_gray );
 
  ###first defrag the gray 
  run( "mincdefrag", $temp_gray, $temp_gray_defrag, "1", "27", "100000" );

  ###then go through iterations of blur and remove until converged
  while (!$done && $count<50){
    run( "mincblur", "-clobber", "-fwhm", "2", $temp_gray_defrag, 
         $temp_gray_blur_prefix );
 
    run( "minccalc", "-clobber", "-expr", 
         'out=(A[0]>0.45&&abs(A[1]-1)<0.45)||(A[0]>0.001&&A[2]>0.01&&abs(A[1]-1)<0.45);', 
         $temp_gray_blur, $temp_gray_defrag, $temp_white_blur, $temp_gray_new);
    unlink( $temp_gray_blur );
 
    run( "minccalc", "-clobber", "-expr", 'out=abs(A[0]-A[1]);', 
         $temp_gray_defrag, $temp_gray_new, $temp_gray_diff );

    @args = ("mincstats", "-sum", $temp_gray_diff) ;
    print "@args\n" ;
    my $stats_result = `@args` ;
    unlink( $temp_gray_diff );
    my @line = split/\s+/, $stats_result ;
    print ("Iteration:${count}\tVoxels changed:${line[1]}\n") ;

    if ($line[1]<20) { $done = 1 ; }
    $count = $count+1 ;
    run("mv", "-f", $temp_gray_new, $temp_gray_defrag) ;
  }
 
  run( "mincdefrag", $temp_gray_defrag, $temp_gray_new, "1", "27", "100000" );
  unlink( $temp_gray_defrag );
   
  run( "minccalc", "-clobber", "-expr", 
       'if(A[0]<0.5&&A[1]>0.5&&A[2]>0.25){out=2}else{if(A[0]<0.5&&A[1]>0.5&&A[2]<0.25){out=1}else{out=A[3];}}', 
       $temp_gray_new, $temp_gray, $temp_white_blur, $classified, $result );

  unlink( $temp_white_blur );
  unlink( $temp_gray );
  unlink( $temp_gray_new );

}


# create_midline_mask extracts ...
# 
# Problems or comments should be sent to: oliver\@bic.mni.mcgill.ca
# 
# create_midline_mask classified.mnc output.mnc\n".

sub create_midline_mask {

  my $classify = shift;
  my $output = shift;

  my $me = &basename($0);

  my $mid_tmp = "${tmpdir}/mid_tmp.mnc";
  my $callosum_filled  = "${tmpdir}/callosum_filled.mnc";
  my $callosum_extra  = "${tmpdir}/callosum_extra.mnc";
  my $white_filled_left  = "${tmpdir}/white_filled_left.mnc";
  my $white_filled_right  = "${tmpdir}/white_filled_right.mnc";

  # The creation of the midline mask below will work with
  # any template (0.5mm, 1.0mm, for example), assuming that
  # the centerline voxel is at x=0.

  my $dx = `mincinfo -attvalue xspace:step $classify`; chomp( $dx );
  my $xleft = -2*$dx;
  my $xright = 2*$dx;
  run( "mincresample", "-clobber", "-xstart", $xleft, "-xnelements", 1,
       $classify, $mid_tmp );
  run( "minccalc", "-clobber", "-byte", "-expr", "out=abs(A[0]-3)<0.45",
       $mid_tmp, $white_filled_left );
  run( "mincdefrag", $white_filled_left, $white_filled_left, 1, 27, 1000 );
  run( "mincdefrag", $white_filled_left, $white_filled_left, 0, 27, 1000 );
  run( "dilate_volume", $white_filled_left, $white_filled_left, 1, 6, 1 );
  run( "dilate_volume", $white_filled_left, $mid_tmp, 0, 6, 1 );
  run( "mincresample", "-clobber", "-like", $classify, $mid_tmp,
       $white_filled_left );

  run( "mincresample", "-clobber", "-xstart", $xright, "-xnelements", 1,
       $classify, $mid_tmp );
  run( "minccalc", "-clobber", "-byte", "-expr", "out=abs(A[0]-3)<0.45",
       $mid_tmp, $white_filled_right );
  run( "mincdefrag", $white_filled_right, $white_filled_right, 1, 27, 1000 );
  run( "mincdefrag", $white_filled_right, $white_filled_right, 0, 27, 1000 );
  run( "dilate_volume", $white_filled_right, $white_filled_right, 1, 6, 1 );
  run( "dilate_volume", $white_filled_right, $mid_tmp, 0, 6, 1 );
  run( "mincresample", "-clobber", "-like", $classify, $mid_tmp,
       $white_filled_right );

  run( "mincresample", "-clobber", "-xstart", 0, "-xnelements", 1,
       $classify, $mid_tmp );
  run( "minccalc", "-clobber", "-expr", "out=abs(A[0]-3)<0.45",
       $mid_tmp, $callosum_filled );
  unlink( $mid_tmp );
  run( "mincdefrag", $callosum_filled, $callosum_filled, 1, 27, 1000 );
  run( "mincdefrag", $callosum_filled, $mid_tmp, 0, 27, 1000 );
  run( "mincresample", "-clobber", "-like", $classify, $mid_tmp, $callosum_filled );

  run( "dilate_volume", $mid_tmp, $mid_tmp, 1, 6, 1 );
  run( "mincresample", "-clobber", "-like", $classify, $mid_tmp, $callosum_extra );

  run( "dilate_volume", $callosum_filled, $mid_tmp, 1, 6, 1 );

  run( "minccalc", "-clobber", "-byte", "-expr",
       "if(A[2]>0.5){1}else{if(A[0]<0.5&&A[1]>0.5){out=2}else{if(A[3]>0.5||A[4]>0.5){3}else{A[1]}}}",
       $callosum_filled, $mid_tmp, $callosum_extra, $white_filled_left, 
       $white_filled_right, $output );

  unlink( $white_filled_left );
  unlink( $white_filled_right );
  unlink( $callosum_extra );
  unlink( $callosum_filled );
  unlink( $mid_tmp );

}  

# fix custom mask to get all of the ventricles if non-linear transform
# is incomplete. Note: this will overwrite custom_mask.

sub plug_ventricles {

  my $cls = shift;
  my $custom_mask = shift;

  my $custom_mask_new = "${tmpdir}/custom_mask_new.mnc";

  # custom_mask = 1 (subcortical gray), = 2 (cerebellum), = 3 (ventricles).
  # anything that is subcortical gray in the custom_mask will be turned
  # to ventricles (3) if it is CSF in the classified image. anything that
  # is ventricles in the custom_mask will be turned to subcortical gray
  # in the custom mask it if is GM in the classified image.

  run( 'minccalc',  '-clobber', '-quiet', '-byte', '-unsigned','-expr',
       'if(abs(A[0]-1)<0.5&&abs(A[1]-1)<0.5){3}else{if(abs(A[0]-3)<0.5&&abs(A[1]-2)<0.5){1}else{A[0]}}',
       $custom_mask, $cls, $custom_mask_new );
  run( 'mv', '-f', $custom_mask_new, $custom_mask );

  my $cls_plugged = "${tmpdir}/cls_plugged.mnc";
  run( "minccalc", "-byte", "-unsigned", "-clobber", "-expr",
       "if(abs(A[1]-1)<0.5||abs(A[1]-3)<0.5||abs(A[0]-3)<0.5){out=3}else{A[0]}",
       $cls, $custom_mask, $cls_plugged );

  my $csf_mask = "${tmpdir}/csf_mask.mnc";
  run( 'minccalc', '-quiet', '-clobber', '-expr',
       'if((A[1]>0.5&&A[0]<0.5)||abs(A[0]-1)<0.5){1}else{0}',
       $cls_plugged, $cls, $csf_mask );
  run( 'mincdefrag', $csf_mask, $csf_mask, 1, 27, 5 );

  my $csf_groups = "${tmpdir}/csf_groups.mnc";
  run( 'mincmorph', '-clobber', '-unsigned', '-short', '-3D26', '-group',
       $csf_mask, $csf_groups );
  unlink( $csf_mask );

  # dilate through classified csf that's connected to the mask of the ventricles.
  my $custom_mask_dil = "${tmpdir}/custom_mask_dil.mnc";
  run( 'dilate_volume', $custom_mask, $custom_mask_dil, 3, 6, 20, $cls, 0.5, 1.5 );

  # find the groups that are connected to the csf of the dilated ventricles mask.
  my $final_groups = "${tmpdir}/final_groups.mnc";
  run( 'minccalc', '-clobber', '-quiet', '-expr',
       'if(A[0]>1.5&&abs(A[1]-3)<0.5){A[0]}else{0}',
       $csf_groups, $custom_mask_dil, $final_groups );

  my @fg = `print_all_labels $final_groups`;
  my @cg = `print_all_labels $csf_groups`;
  unlink( $custom_mask_dil );
  unlink( $final_groups );

  open LUT, "> ${tmpdir}/table.lut";
  for( my $g1 = 0; $g1 <= $#cg; $g1++ ) {
    $cg[$g1] =~ /Label: ([0-9]+) ([0-9]+)/;
    my $label = $1;
    my $count = $2;
 
    my $new_label = 0;
    for( my $g2 = 0; $g2 <= $#fg; $g2++ ) {
      $fg[$g2] =~ /Label: ([0-9]+) ([0-9]+)/;
      if( $1 == $label ) {
        $new_label = 1;
        last;
      }
    }
    print LUT "$label $new_label\n";
  }
  close( LUT );

  my $csf_extra = "${tmpdir}/csf_extra.mnc";
  &run( 'minclookup', '-clob', '-quiet', '-discrete', '-lookup_table',
        "${tmpdir}/table.lut", $csf_groups, $csf_extra );
  unlink( $csf_groups );
  unlink( "${tmpdir}/table.lut" );

  # expand one layer to try to account for partial volume effects.
  run( 'dilate_volume', $csf_extra, $csf_extra, 1, 6, 1 );

  # final correction to the custom mask.
  run( 'minccalc', '-quiet', '-clobber', '-expr',
       'if(A[1]>0.5){3}else{A[0]}', $custom_mask, $csf_extra,
       $custom_mask_new );
  run( 'mv', '-f', $custom_mask_new, $custom_mask );
}


#Execute a system call.

sub run {
  print shellquote(@_), "\n";
  system(@_)==0 or die "Command @_ failed with status: $?";
}


