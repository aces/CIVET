#! /usr/bin/env perl
#
# Surface Feature Extractor
#
# Oliver Lyttelton oliver@bic.mni.mcgill.ca

#

use strict;
use warnings "all";
use Getopt::Tabular;
use File::Basename;
use File::Temp qw/ tempdir /;


my($Help, $Usage, $me);
my(@opt_table, $source, $target, $outxfm, @args, $tmpdir);

$me = &basename($0);

my $feature_choice = 0;
my $measurement_choice = 0;
my $extraction_transform = undef;
my $blurfwhm = undef;
my $alignment_transform = undef;
my $model_mid_surface = undef;
my $verbose = 0;
my $clobber = 0;
my $template_paint = undef;
my $template_labels = undef;
my $flip_transform = undef;
my $volume_feature = undef;
my $volume_feature_intersect = undef;

   
$Help = <<HELP;
|    $me extracts a surface feature set with options to 
|    choose the feature,  the type of measurement (roi vs vbc)
|    vary the extraction space (native or tal) the blurring kernel,
|    the registration space (tal or nl tal),
| 
| Problems or comments should be sent to: oliver\@bic.mni.mcgill.ca
HELP

$Usage = "Usage: $me [options] classified.mnc hemi_model_dir output_left_hemi.mnc output_right_hemi.mnc\n".
         "       $me -help to list options\n\n";

@opt_table = (
         
        ["-verbose","const","1", \$verbose,
        "be verbose" ],
        ["-clobber", "const","1", \$clobber,
        "clobber existing check features" ],  
   );

# Check arguments
&Getopt::Tabular::SetHelp($Help, $Usage);
&GetOptions (\@opt_table, \@ARGV) || exit 1;
die $Usage if($#ARGV != 4);
my $classify = shift(@ARGV);
my $brain_mask = shift(@ARGV);
my $hemi_model_dir= shift(@ARGV);
my $output_left_hemi = shift(@ARGV);
my $output_right_hemi = shift(@ARGV);

# make tmpdir
$tmpdir = &tempdir( "$me-XXXXXXXX", TMPDIR => 1, CLEANUP => 1 );


my $classify_masked = "${tmpdir}/classify_masked.mnc";
my $wm_crop_left = "${tmpdir}/wm_crop_left.mnc";
my $wm_crop_right  = "${tmpdir}/wm_crop_right.mnc";
my $wm_defrag_left  = "${tmpdir}/wm_defrag_left.mnc";
my $wm_defrag_right  = "${tmpdir}/wm_defrag_right.mnc";
my $wm_add_back_left  = "${tmpdir}/wm_add_back_left.mnc";
my $wm_add_back_right    = "${tmpdir}/wm_add_back_right.mnc";
my $hemi_left_mask = "${hemi_model_dir}/hemi_left_mask.mnc"; 
my $hemi_right_mask = "${hemi_model_dir}/hemi_right_mask.mnc";
my $slide_left_xfm =  "${hemi_model_dir}/slide_left.xfm";
my $slide_right_xfm =  "${hemi_model_dir}/slide_right.xfm";

# for flipping the right WM mask to look like a left
my $wm_preflip_right = "${tmpdir}/wm_preflip_right.mnc";
my $flip_right_xfm =  "${hemi_model_dir}/flip_right.xfm";

                
#set up internal variables

&do_cmd("minccalc", "-clobber", "-expr", "if(A[1]>0.5){out=A[0];}else{out=0;}",
        $classify, $brain_mask, $classify_masked );

&do_cmd("minccalc","-clobber","-expr","out=(abs(A[0]-3)<0.45)&&A[1];",
        $classify_masked,$hemi_left_mask,$wm_crop_left);

&do_cmd("minccalc","-clobber","-expr","out=(abs(A[0]-3)<0.45)&&A[1];",
        $classify_masked,$hemi_right_mask,$wm_crop_right);
 	
&do_cmd("mincdefrag",$wm_crop_left,$wm_defrag_left,"1","27","100000");

&do_cmd("mincdefrag",$wm_crop_right,$wm_defrag_right,"1","27","100000");

&do_cmd("minccalc","-clobber","-expr","out=A[0]||(A[1]&&!A[2]);",$wm_defrag_left,$wm_crop_right,$wm_defrag_right,$wm_add_back_left);

&do_cmd("minccalc","-clobber","-expr","out=A[0]||(A[1]&&!A[2]);",$wm_defrag_right,$wm_crop_left,$wm_defrag_left,$wm_add_back_right);

&do_cmd("mincresample","-clobber","-like",$wm_add_back_left,"-transform",$slide_right_xfm,$wm_add_back_left,$output_left_hemi);

&do_cmd("mincresample","-clobber","-like",$wm_add_back_right,"-transform",$slide_left_xfm,$wm_add_back_right,$wm_preflip_right );

&do_cmd("mincresample","-clobber","-like",$wm_preflip_right,"-transform",$flip_right_xfm,$wm_preflip_right,$output_right_hemi);



sub do_cmd { 
   print STDOUT "@_\n" if ($verbose);
   system(@_) == 0 or die;
}

